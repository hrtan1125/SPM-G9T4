{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { getGridDefaultColumnTypes, GridLinkOperator } from '@mui/x-data-grid-pro';\nimport { isDeepEqual } from '@mui/x-data-grid/internals';\nimport { useDemoData, getColumnsFromOptions, getInitialState } from './useDemoData';\n\nconst simplifiedValueGetter = (field, colDef) => row => {\n  var _colDef$valueGetter;\n\n  const params = {\n    id: row.id,\n    row,\n    field,\n    rowNode: {}\n  }; // @ts-ignore\n\n  return ((_colDef$valueGetter = colDef.valueGetter) == null ? void 0 : _colDef$valueGetter.call(colDef, params)) || row[field];\n};\n\nconst getRowComparator = (sortModel, columnsWithDefaultColDef) => {\n  if (!sortModel) {\n    const comparator = () => 0;\n\n    return comparator;\n  }\n\n  const sortOperators = sortModel.map(sortItem => {\n    const columnField = sortItem.field;\n    const colDef = columnsWithDefaultColDef.find(_ref => {\n      let {\n        field\n      } = _ref;\n      return field === columnField;\n    });\n    return _extends({}, sortItem, {\n      valueGetter: simplifiedValueGetter(columnField, colDef),\n      sortComparator: colDef.sortComparator\n    });\n  });\n\n  const comparator = (row1, row2) => sortOperators.reduce((acc, _ref2) => {\n    let {\n      valueGetter,\n      sort,\n      sortComparator\n    } = _ref2;\n\n    if (acc !== 0) {\n      return acc;\n    }\n\n    const v1 = valueGetter(row1);\n    const v2 = valueGetter(row2);\n    return sort === 'desc' ? -1 * sortComparator(v1, v2) : sortComparator(v1, v2);\n  }, 0);\n\n  return comparator;\n};\n\nconst getFilteredRows = (rows, filterModel, columnsWithDefaultColDef) => {\n  if (filterModel === undefined || filterModel.items.length === 0) {\n    return rows;\n  }\n\n  const valueGetters = filterModel.items.map(_ref3 => {\n    let {\n      columnField\n    } = _ref3;\n    return simplifiedValueGetter(columnField, columnsWithDefaultColDef.find(_ref4 => {\n      let {\n        field\n      } = _ref4;\n      return field === columnField;\n    }));\n  });\n  const filterFunctions = filterModel.items.map(filterItem => {\n    const {\n      columnField,\n      operatorValue\n    } = filterItem;\n    const colDef = columnsWithDefaultColDef.find(_ref5 => {\n      let {\n        field\n      } = _ref5;\n      return field === columnField;\n    });\n    const filterOperator = colDef.filterOperators.find(_ref6 => {\n      let {\n        value\n      } = _ref6;\n      return operatorValue === value;\n    });\n    let parsedValue = filterItem.value;\n\n    if (colDef.valueParser) {\n      var _filterItem$value;\n\n      const parser = colDef.valueParser;\n      parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(x => parser(x)) : parser(filterItem.value);\n    }\n\n    return filterOperator == null ? void 0 : filterOperator.getApplyFilterFn({\n      filterItem,\n      value: parsedValue\n    }, colDef);\n  });\n\n  if (filterModel.linkOperator === GridLinkOperator.Or) {\n    return rows.filter(row => filterModel.items.some((_, index) => {\n      const value = valueGetters[index](row);\n      return filterFunctions[index] === null ? true : filterFunctions[index]({\n        value\n      });\n    }));\n  }\n\n  return rows.filter(row => filterModel.items.every((_, index) => {\n    const value = valueGetters[index](row);\n    return filterFunctions[index] === null ? true : filterFunctions[index]({\n      value\n    });\n  }));\n};\n/**\n * Simulates server data loading\n */\n\n\nexport const loadServerRows = (rows, queryOptions, serverOptions, columnsWithDefaultColDef) => {\n  const {\n    minDelay = 100,\n    maxDelay = 300,\n    useCursorPagination\n  } = serverOptions;\n\n  if (maxDelay < minDelay) {\n    throw new Error('serverOptions.minDelay is larger than serverOptions.maxDelay ');\n  }\n\n  const delay = Math.random() * (maxDelay - minDelay) + minDelay;\n  const {\n    cursor,\n    page = 0,\n    pageSize\n  } = queryOptions;\n  let nextCursor;\n  let firstRowIndex;\n  let lastRowIndex;\n  let filteredRows = getFilteredRows(rows, queryOptions.filterModel, columnsWithDefaultColDef);\n  const rowComparator = getRowComparator(queryOptions.sortModel, columnsWithDefaultColDef);\n  filteredRows = [...filteredRows].sort(rowComparator);\n  const totalRowCount = filteredRows.length;\n\n  if (!pageSize) {\n    firstRowIndex = 0;\n    lastRowIndex = filteredRows.length;\n  } else if (useCursorPagination) {\n    firstRowIndex = cursor ? filteredRows.findIndex(_ref7 => {\n      let {\n        id\n      } = _ref7;\n      return id === cursor;\n    }) : 0;\n    firstRowIndex = Math.max(firstRowIndex, 0); // if cursor not found return 0\n\n    lastRowIndex = firstRowIndex + pageSize;\n    nextCursor = lastRowIndex >= filteredRows.length ? undefined : filteredRows[lastRowIndex].id;\n  } else {\n    firstRowIndex = page * pageSize;\n    lastRowIndex = (page + 1) * pageSize;\n  }\n\n  const response = {\n    returnedRows: filteredRows.slice(firstRowIndex, lastRowIndex),\n    nextCursor,\n    totalRowCount\n  };\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(response);\n    }, delay); // simulate network latency\n  });\n};\nconst DEFAULT_DATASET_OPTIONS = {\n  dataSet: 'Commodity',\n  rowLength: 100,\n  maxColumns: 6\n};\nconst disableDelay = typeof DISABLE_CHANCE_RANDOM !== 'undefined' && DISABLE_CHANCE_RANDOM;\nconst DEFAULT_SERVER_OPTIONS = {\n  minDelay: disableDelay ? 0 : 100,\n  maxDelay: disableDelay ? 0 : 300,\n  useCursorPagination: true\n};\nexport const createFakeServer = (dataSetOptions, serverOptions) => {\n  const dataSetOptionsWithDefault = _extends({}, DEFAULT_DATASET_OPTIONS, dataSetOptions);\n\n  const serverOptionsWithDefault = _extends({}, DEFAULT_SERVER_OPTIONS, serverOptions);\n\n  const columns = getColumnsFromOptions(dataSetOptionsWithDefault);\n  const initialState = getInitialState(dataSetOptionsWithDefault, columns);\n  const defaultColDef = getGridDefaultColumnTypes();\n  const columnsWithDefaultColDef = columns.map(column => _extends({}, defaultColDef[column.type || 'string'], column));\n\n  const useQuery = queryOptions => {\n    const {\n      data: {\n        rows\n      },\n      loading: dataGenerationIsLoading\n    } = useDemoData(dataSetOptionsWithDefault);\n    const queryOptionsRef = React.useRef(queryOptions);\n    const [response, setResponse] = React.useState({\n      pageInfo: {},\n      data: []\n    });\n    const [isLoading, setIsLoading] = React.useState(dataGenerationIsLoading);\n    React.useEffect(() => {\n      if (dataGenerationIsLoading) {\n        // dataset is not ready\n        return () => {};\n      }\n\n      queryOptionsRef.current = queryOptions;\n      let active = true;\n      setIsLoading(true);\n      setResponse(prev => Object.keys(prev.pageInfo).length === 0 ? prev : _extends({}, prev, {\n        pageInfo: {}\n      }));\n\n      (async function fetchData() {\n        const {\n          returnedRows,\n          nextCursor,\n          totalRowCount\n        } = await loadServerRows(rows, queryOptions, serverOptionsWithDefault, columnsWithDefaultColDef);\n\n        if (!active) {\n          return;\n        }\n\n        const newRep = {\n          data: returnedRows,\n          pageInfo: {\n            totalRowCount,\n            nextCursor,\n            pageSize: returnedRows.length\n          }\n        };\n        setResponse(prev => isDeepEqual(prev, newRep) ? prev : newRep);\n        setIsLoading(false);\n      })();\n\n      return () => {\n        active = false;\n      };\n    }, [dataGenerationIsLoading, queryOptions, rows]); // We use queryOptions pointer to be sure that isLoading===true as soon as the options change\n\n    const effectShouldStart = queryOptionsRef.current !== queryOptions;\n    return _extends({\n      isLoading: isLoading || effectShouldStart\n    }, response);\n  };\n\n  return {\n    columns,\n    columnsWithDefaultColDef,\n    initialState,\n    useQuery\n  };\n};","map":null,"metadata":{},"sourceType":"module"}