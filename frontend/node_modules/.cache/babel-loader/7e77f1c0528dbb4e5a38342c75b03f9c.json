{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { randomArrayItem } from './random-generator';\nexport const addTreeDataOptionsToDemoData = function (data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _groupingCol$headerNa;\n\n  const {\n    averageChildren = 2,\n    maxDepth = 1,\n    groupingField\n  } = options;\n  const hasTreeData = maxDepth > 1 && groupingField != null;\n\n  if (!hasTreeData) {\n    return data;\n  }\n\n  if (data.rows.length > 1000) {\n    throw new Error('MUI: useDemoData tree data mode only works up to 1000 rows.');\n  }\n\n  const rowsByTreeDepth = {};\n  const rowsCount = data.rows.length;\n  const groupingCol = data.columns.find(col => col.field === options.groupingField);\n\n  if (!groupingCol) {\n    throw new Error('MUI: The tree data grouping field does not exist');\n  }\n\n  data.initialState.columns.columnVisibilityModel[groupingField] = false;\n\n  for (let i = 0; i < rowsCount; i += 1) {\n    const row = data.rows[i];\n    const currentChunk = Math.floor(i * (averageChildren ** maxDepth - 1) / rowsCount) + 1;\n    const currentDepth = Math.floor(Math.log(currentChunk) / Math.log(averageChildren));\n\n    if (!rowsByTreeDepth[currentDepth]) {\n      rowsByTreeDepth[currentDepth] = {\n        rows: {},\n        rowIndexes: []\n      };\n    }\n\n    rowsByTreeDepth[currentDepth].rows[i] = {\n      value: row,\n      parentIndex: null\n    };\n    rowsByTreeDepth[currentDepth].rowIndexes.push(i);\n  }\n\n  Object.entries(rowsByTreeDepth).forEach(_ref => {\n    let [depthStr, {\n      rows\n    }] = _ref;\n    const depth = Number(depthStr);\n    Object.values(rows).forEach(row => {\n      const path = [];\n      let previousRow = null;\n\n      for (let k = depth; k >= 0; k -= 1) {\n        let rowTemp;\n\n        if (k === depth) {\n          if (depth > 0) {\n            row.parentIndex = Number(randomArrayItem(rowsByTreeDepth[depth - 1].rowIndexes));\n          }\n\n          rowTemp = row;\n        } else {\n          rowTemp = rowsByTreeDepth[k].rows[previousRow.parentIndex];\n        }\n\n        path.unshift(rowTemp.value[groupingField]);\n        previousRow = rowTemp;\n      }\n\n      row.value.path = path;\n    });\n  });\n  return _extends({}, data, {\n    groupingColDef: {\n      headerName: (_groupingCol$headerNa = groupingCol.headerName) != null ? _groupingCol$headerNa : groupingCol.field,\n      width: 250\n    },\n    getTreeDataPath: row => row.path,\n    treeData: true\n  });\n};","map":null,"metadata":{},"sourceType":"module"}