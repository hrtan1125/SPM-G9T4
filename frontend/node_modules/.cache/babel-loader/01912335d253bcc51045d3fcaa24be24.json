{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"hideDescendantCount\"];\nimport * as React from 'react';\nimport { gridRowIdsSelector, gridRowTreeSelector, useFirstRender, GRID_CHECKBOX_SELECTION_FIELD } from '@mui/x-data-grid';\nimport { useGridRegisterPipeProcessor, useGridRegisterStrategyProcessor } from '@mui/x-data-grid/internals';\nimport { GRID_TREE_DATA_GROUPING_COL_DEF, GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES } from './gridTreeDataGroupColDef';\nimport { filterRowTreeFromTreeData, TREE_DATA_STRATEGY } from './gridTreeDataUtils';\nimport { GridTreeDataGroupingCell } from '../../../components';\nimport { buildRowTree } from '../../../utils/tree/buildRowTree';\nimport { sortRowTree } from '../../../utils/tree/sortRowTree';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const useGridTreeDataPreProcessors = (apiRef, props) => {\n  const setStrategyAvailability = React.useCallback(() => {\n    apiRef.current.unstable_setStrategyAvailability('rowTree', TREE_DATA_STRATEGY, props.treeData ? () => true : () => false);\n  }, [apiRef, props.treeData]);\n  const getGroupingColDef = React.useCallback(() => {\n    var _colDefOverride;\n\n    const groupingColDefProp = props.groupingColDef;\n    let colDefOverride;\n\n    if (typeof groupingColDefProp === 'function') {\n      const params = {\n        groupingName: TREE_DATA_STRATEGY,\n        fields: []\n      };\n      colDefOverride = groupingColDefProp(params);\n    } else {\n      colDefOverride = groupingColDefProp;\n    }\n\n    const _ref = (_colDefOverride = colDefOverride) != null ? _colDefOverride : {},\n          {\n      hideDescendantCount\n    } = _ref,\n          colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n    const commonProperties = _extends({}, GRID_TREE_DATA_GROUPING_COL_DEF, {\n      renderCell: params => /*#__PURE__*/_jsx(GridTreeDataGroupingCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      })),\n      headerName: apiRef.current.getLocaleText('treeDataGroupingHeaderName')\n    });\n\n    return _extends({}, commonProperties, colDefOverrideProperties, GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES);\n  }, [apiRef, props.groupingColDef]);\n  const updateGroupingColumn = React.useCallback(columnsState => {\n    const groupingColDefField = GRID_TREE_DATA_GROUPING_COL_DEF_FORCED_PROPERTIES.field;\n    const shouldHaveGroupingColumn = props.treeData;\n    const prevGroupingColumn = columnsState.lookup[groupingColDefField];\n\n    if (shouldHaveGroupingColumn) {\n      const newGroupingColumn = getGroupingColDef();\n\n      if (prevGroupingColumn) {\n        newGroupingColumn.width = prevGroupingColumn.width;\n        newGroupingColumn.flex = prevGroupingColumn.flex;\n      }\n\n      columnsState.lookup[groupingColDefField] = newGroupingColumn;\n\n      if (prevGroupingColumn == null) {\n        const index = columnsState.all[0] === GRID_CHECKBOX_SELECTION_FIELD ? 1 : 0;\n        columnsState.all = [...columnsState.all.slice(0, index), groupingColDefField, ...columnsState.all.slice(index)];\n      }\n    } else if (!shouldHaveGroupingColumn && prevGroupingColumn) {\n      delete columnsState.lookup[groupingColDefField];\n      columnsState.all = columnsState.all.filter(field => field !== groupingColDefField);\n    }\n\n    return columnsState;\n  }, [props.treeData, getGroupingColDef]);\n  const createRowTree = React.useCallback(params => {\n    if (!props.getTreeDataPath) {\n      throw new Error('MUI: No getTreeDataPath given.');\n    }\n\n    const rows = params.ids.map(rowId => ({\n      id: rowId,\n      path: props.getTreeDataPath(params.idRowsLookup[rowId]).map(key => ({\n        key,\n        field: null\n      }))\n    })).sort((a, b) => a.path.length - b.path.length);\n    return buildRowTree(_extends({\n      rows\n    }, params, {\n      defaultGroupingExpansionDepth: props.defaultGroupingExpansionDepth,\n      isGroupExpandedByDefault: props.isGroupExpandedByDefault,\n      groupingName: TREE_DATA_STRATEGY,\n      onDuplicatePath: (firstId, secondId, path) => {\n        throw new Error(['MUI: The path returned by `getTreeDataPath` should be unique.', `The rows with id #${firstId} and #${secondId} have the same.`, `Path: ${JSON.stringify(path.map(step => step.key))}.`].join('\\n'));\n      }\n    }));\n  }, [props.getTreeDataPath, props.defaultGroupingExpansionDepth, props.isGroupExpandedByDefault]);\n  const filterRows = React.useCallback(params => {\n    const rowTree = gridRowTreeSelector(apiRef);\n    return filterRowTreeFromTreeData({\n      rowTree,\n      isRowMatchingFilters: params.isRowMatchingFilters,\n      disableChildrenFiltering: props.disableChildrenFiltering,\n      filterModel: params.filterModel,\n      apiRef\n    });\n  }, [apiRef, props.disableChildrenFiltering]);\n  const sortRows = React.useCallback(params => {\n    const rowTree = gridRowTreeSelector(apiRef);\n    const rowIds = gridRowIdsSelector(apiRef);\n    return sortRowTree({\n      rowTree,\n      rowIds,\n      sortRowList: params.sortRowList,\n      disableChildrenSorting: props.disableChildrenSorting\n    });\n  }, [apiRef, props.disableChildrenSorting]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateColumns', updateGroupingColumn);\n  useGridRegisterStrategyProcessor(apiRef, TREE_DATA_STRATEGY, 'rowTreeCreation', createRowTree);\n  useGridRegisterStrategyProcessor(apiRef, TREE_DATA_STRATEGY, 'filtering', filterRows);\n  useGridRegisterStrategyProcessor(apiRef, TREE_DATA_STRATEGY, 'sorting', sortRows);\n  /**\n   * 1ST RENDER\n   */\n\n  useFirstRender(() => {\n    setStrategyAvailability();\n  });\n  /**\n   * EFFECTS\n   */\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (!isFirstRender.current) {\n      setStrategyAvailability();\n    } else {\n      isFirstRender.current = false;\n    }\n  }, [setStrategyAvailability]);\n};","map":null,"metadata":{},"sourceType":"module"}