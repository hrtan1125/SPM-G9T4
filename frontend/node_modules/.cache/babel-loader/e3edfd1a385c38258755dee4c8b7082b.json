{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nexport function addPinnedRow(_ref) {\n  let {\n    groupingParams,\n    rowModel,\n    rowId,\n    position,\n    apiRef\n  } = _ref;\n\n  var _groupingParams$addit;\n\n  const idRowsLookup = _extends({}, groupingParams.idRowsLookup);\n\n  const tree = _extends({}, groupingParams.tree); // TODO: warn if id is already present in `props.rows`\n\n\n  idRowsLookup[rowId] = rowModel; // Do not push it to ids list so that pagination is not affected by pinned rows\n  // ids.push(rowId);\n\n  tree[rowId] = {\n    id: rowId,\n    isAutoGenerated: false,\n    parent: null,\n    depth: 0,\n    groupingKey: null,\n    groupingField: null,\n    isPinned: true\n  };\n  apiRef.current.unstable_caches.rows.idRowsLookup[rowId] = _extends({}, rowModel);\n  apiRef.current.unstable_caches.rows.idToIdLookup[rowId] = rowId;\n  const previousPinnedRows = ((_groupingParams$addit = groupingParams.additionalRowGroups) == null ? void 0 : _groupingParams$addit.pinnedRows) || {};\n  const newPinnedRow = {\n    id: rowId,\n    model: rowModel\n  };\n  return _extends({}, groupingParams, {\n    idRowsLookup,\n    tree,\n    additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n      pinnedRows: _extends({}, previousPinnedRows, {\n        [position]: [...(previousPinnedRows[position] || []), newPinnedRow]\n      })\n    })\n  });\n}\nexport const useGridRowPinningPreProcessors = apiRef => {\n  const addPinnedRows = React.useCallback(groupingParams => {\n    var _pinnedRowsCache$topI, _pinnedRowsCache$bott;\n\n    const pinnedRowsCache = apiRef.current.unstable_caches.pinnedRows || {};\n\n    let newGroupingParams = _extends({}, groupingParams, {\n      additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n        // reset pinned rows state\n        pinnedRows: {}\n      })\n    });\n\n    (_pinnedRowsCache$topI = pinnedRowsCache.topIds) == null ? void 0 : _pinnedRowsCache$topI.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'top',\n        apiRef\n      });\n    });\n    (_pinnedRowsCache$bott = pinnedRowsCache.bottomIds) == null ? void 0 : _pinnedRowsCache$bott.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'bottom',\n        apiRef\n      });\n    }); // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from `ids`\n\n    newGroupingParams.ids = newGroupingParams.ids.filter(rowId => {\n      if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].isPinned) {\n        return false;\n      }\n\n      return true;\n    });\n    return newGroupingParams;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addPinnedRows);\n};","map":null,"metadata":{},"sourceType":"module"}