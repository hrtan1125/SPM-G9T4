{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { gridColumnLookupSelector, gridRowIdsSelector, gridRowTreeSelector, useFirstRender, GRID_CHECKBOX_SELECTION_FIELD } from '@mui/x-data-grid-pro';\nimport { useGridRegisterPipeProcessor, useGridRegisterStrategyProcessor, sortRowTree, buildRowTree } from '@mui/x-data-grid-pro/internals';\nimport { gridRowGroupingModelSelector, gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { createGroupingColDefForAllGroupingCriteria, createGroupingColDefForOneGroupingCriteria } from './createGroupingColDef';\nimport { filterRowTreeFromGroupingColumns, getColDefOverrides, ROW_GROUPING_STRATEGY, isGroupingColumn, setStrategyAvailability, getGroupingRules } from './gridRowGroupingUtils';\nexport const useGridRowGroupingPreProcessors = (apiRef, props) => {\n  const getGroupingColDefs = React.useCallback(columnsState => {\n    if (props.disableRowGrouping) {\n      return [];\n    }\n\n    const groupingColDefProp = props.groupingColDef; // We can't use `gridGroupingRowsSanitizedModelSelector` here because the new columns are not in the state yet\n\n    const rowGroupingModel = gridRowGroupingModelSelector(apiRef).filter(field => !!columnsState.lookup[field]);\n\n    if (rowGroupingModel.length === 0) {\n      return [];\n    }\n\n    switch (props.rowGroupingColumnMode) {\n      case 'single':\n        {\n          return [createGroupingColDefForAllGroupingCriteria({\n            apiRef,\n            rowGroupingModel,\n            colDefOverride: getColDefOverrides(groupingColDefProp, rowGroupingModel),\n            columnsLookup: columnsState.lookup\n          })];\n        }\n\n      case 'multiple':\n        {\n          return rowGroupingModel.map(groupingCriteria => createGroupingColDefForOneGroupingCriteria({\n            groupingCriteria,\n            colDefOverride: getColDefOverrides(groupingColDefProp, [groupingCriteria]),\n            groupedByColDef: columnsState.lookup[groupingCriteria],\n            columnsLookup: columnsState.lookup\n          }));\n        }\n\n      default:\n        {\n          return [];\n        }\n    }\n  }, [apiRef, props.groupingColDef, props.rowGroupingColumnMode, props.disableRowGrouping]);\n  const updateGroupingColumn = React.useCallback(columnsState => {\n    const groupingColDefs = getGroupingColDefs(columnsState);\n    let newColumnFields = [];\n    const newColumnsLookup = {}; // We only keep the non-grouping columns\n\n    columnsState.all.forEach(field => {\n      if (!isGroupingColumn(field)) {\n        newColumnFields.push(field);\n        newColumnsLookup[field] = columnsState.lookup[field];\n      }\n    }); // We add the grouping column\n\n    groupingColDefs.forEach(groupingColDef => {\n      const matchingGroupingColDef = columnsState.lookup[groupingColDef.field];\n\n      if (matchingGroupingColDef) {\n        groupingColDef.width = matchingGroupingColDef.width;\n        groupingColDef.flex = matchingGroupingColDef.flex;\n      }\n\n      newColumnsLookup[groupingColDef.field] = groupingColDef;\n    });\n    const startIndex = newColumnFields[0] === GRID_CHECKBOX_SELECTION_FIELD ? 1 : 0;\n    newColumnFields = [...newColumnFields.slice(0, startIndex), ...groupingColDefs.map(colDef => colDef.field), ...newColumnFields.slice(startIndex)];\n    columnsState.all = newColumnFields;\n    columnsState.lookup = newColumnsLookup;\n    return columnsState;\n  }, [getGroupingColDefs]);\n  const createRowTree = React.useCallback(params => {\n    const sanitizedRowGroupingModel = gridRowGroupingSanitizedModelSelector(apiRef);\n    const columnsLookup = gridColumnLookupSelector(apiRef);\n    const groupingRules = getGroupingRules({\n      sanitizedRowGroupingModel,\n      columnsLookup\n    });\n    apiRef.current.unstable_caches.rowGrouping.rulesOnLastRowTreeCreation = groupingRules;\n\n    const getCellGroupingCriteria = _ref => {\n      let {\n        row,\n        id,\n        colDef,\n        groupingRule\n      } = _ref;\n      let key;\n\n      if (groupingRule.groupingValueGetter) {\n        const groupingValueGetterParams = {\n          colDef,\n          field: groupingRule.field,\n          value: row[groupingRule.field],\n          id,\n          row,\n          rowNode: {\n            isAutoGenerated: false,\n            id\n          }\n        };\n        key = groupingRule.groupingValueGetter(groupingValueGetterParams);\n      } else {\n        key = row[groupingRule.field];\n      }\n\n      return {\n        key,\n        field: colDef.field\n      };\n    };\n\n    const rows = params.ids.map(rowId => {\n      const row = params.idRowsLookup[rowId];\n      const parentPath = groupingRules.map(groupingRule => getCellGroupingCriteria({\n        row,\n        id: rowId,\n        groupingRule,\n        colDef: columnsLookup[groupingRule.field]\n      })).filter(cell => cell.key != null);\n      const leafGroupingCriteria = {\n        key: rowId.toString(),\n        field: null\n      };\n      return {\n        path: [...parentPath, leafGroupingCriteria],\n        id: rowId\n      };\n    });\n    return buildRowTree(_extends({}, params, {\n      rows,\n      defaultGroupingExpansionDepth: props.defaultGroupingExpansionDepth,\n      isGroupExpandedByDefault: props.isGroupExpandedByDefault,\n      groupingName: ROW_GROUPING_STRATEGY\n    }));\n  }, [apiRef, props.defaultGroupingExpansionDepth, props.isGroupExpandedByDefault]);\n  const filterRows = React.useCallback(params => {\n    const rowTree = gridRowTreeSelector(apiRef);\n    return filterRowTreeFromGroupingColumns({\n      rowTree,\n      isRowMatchingFilters: params.isRowMatchingFilters,\n      filterModel: params.filterModel,\n      apiRef\n    });\n  }, [apiRef]);\n  const sortRows = React.useCallback(params => {\n    const rowTree = gridRowTreeSelector(apiRef);\n    const rowIds = gridRowIdsSelector(apiRef);\n    return sortRowTree({\n      rowTree,\n      rowIds,\n      sortRowList: params.sortRowList,\n      disableChildrenSorting: false\n    });\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateColumns', updateGroupingColumn);\n  useGridRegisterStrategyProcessor(apiRef, ROW_GROUPING_STRATEGY, 'rowTreeCreation', createRowTree);\n  useGridRegisterStrategyProcessor(apiRef, ROW_GROUPING_STRATEGY, 'filtering', filterRows);\n  useGridRegisterStrategyProcessor(apiRef, ROW_GROUPING_STRATEGY, 'sorting', sortRows);\n  /**\n   * 1ST RENDER\n   */\n\n  useFirstRender(() => {\n    setStrategyAvailability(apiRef, props.disableRowGrouping);\n  });\n  /**\n   * EFFECTS\n   */\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (!isFirstRender.current) {\n      setStrategyAvailability(apiRef, props.disableRowGrouping);\n    } else {\n      isFirstRender.current = false;\n    }\n  }, [apiRef, props.disableRowGrouping]);\n};","map":null,"metadata":{},"sourceType":"module"}