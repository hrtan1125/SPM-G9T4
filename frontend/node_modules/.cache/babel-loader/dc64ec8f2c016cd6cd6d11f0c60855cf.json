{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_DATE_COL_DEF, GRID_DATETIME_COL_DEF } from '@mui/x-data-grid-pro';\nimport { buildWarning } from '@mui/x-data-grid/internals';\n\nconst getExcelJs = async () => {\n  const {\n    default: excelJsDefault\n  } = await import('exceljs');\n  return excelJsDefault;\n};\n\nconst warnInvalidFormattedValue = buildWarning(['MUI: When the value of a field is an object or a `renderCell` is provided, the Excel export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);\n\nconst getFormattedValueOptions = (colDef, valueOptions, api) => {\n  if (!colDef.valueOptions) {\n    return [];\n  }\n\n  let valueOptionsFormatted = valueOptions;\n\n  if (colDef.valueFormatter) {\n    valueOptionsFormatted = valueOptionsFormatted.map(option => {\n      if (typeof option === 'object') {\n        return option;\n      }\n\n      const params = {\n        field: colDef.field,\n        api,\n        value: option\n      };\n      return String(colDef.valueFormatter(params));\n    });\n  }\n\n  return valueOptionsFormatted.map(option => typeof option === 'object' ? option.label : option);\n};\n\nconst serializeRow = (id, columns, api, defaultValueOptionsFormulae) => {\n  const row = {};\n  const dataValidation = {};\n  const mergedCells = [];\n  const firstCellParams = api.getCellParams(id, columns[0].field);\n  const outlineLevel = firstCellParams.rowNode.depth; // `colSpan` is only calculated for rendered rows, so we need to calculate it during export for every row\n\n  api.unstable_calculateColSpan({\n    rowId: id,\n    minFirstColumn: 0,\n    maxLastColumn: columns.length,\n    columns\n  });\n  columns.forEach((column, colIndex) => {\n    const colSpanInfo = api.unstable_getCellColSpanInfo(id, colIndex);\n\n    if (colSpanInfo && colSpanInfo.spannedByColSpan) {\n      return;\n    }\n\n    if (colSpanInfo && colSpanInfo.cellProps.colSpan > 1) {\n      mergedCells.push({\n        leftIndex: colIndex + 1,\n        rightIndex: colIndex + colSpanInfo.cellProps.colSpan\n      });\n    }\n\n    const cellParams = api.getCellParams(id, column.field);\n\n    switch (cellParams.colDef.type) {\n      case 'singleSelect':\n        {\n          var _formattedValue$label;\n\n          if (typeof cellParams.colDef.valueOptions === 'function') {\n            // If value option depends on the row, set specific options to the cell\n            // This dataValidation is buggy with LibreOffice and does not allow to have coma\n            const valueOptions = cellParams.colDef.valueOptions({\n              id,\n              row,\n              field: cellParams.field\n            });\n            const formattedValueOptions = getFormattedValueOptions(cellParams.colDef, valueOptions, api);\n            dataValidation[column.field] = {\n              type: 'list',\n              allowBlank: true,\n              formulae: [`\"${formattedValueOptions.map(x => x.toString().replaceAll(',', 'CHAR(44)')).join(',')}\"`]\n            };\n          } else {\n            // If value option is defined for the column, refer to another sheet\n            dataValidation[column.field] = {\n              type: 'list',\n              allowBlank: true,\n              formulae: [defaultValueOptionsFormulae[column.field]]\n            };\n          }\n\n          const formattedValue = api.getCellParams(id, column.field).formattedValue;\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (String(cellParams.formattedValue) === '[object Object]') {\n              warnInvalidFormattedValue();\n            }\n          }\n\n          row[column.field] = (_formattedValue$label = formattedValue == null ? void 0 : formattedValue.label) != null ? _formattedValue$label : formattedValue;\n          break;\n        }\n\n      case 'boolean':\n      case 'number':\n        row[column.field] = api.getCellParams(id, column.field).value;\n        break;\n\n      case 'date':\n      case 'dateTime':\n        {\n          // Excel does not do any timezone conversion, so we create a date using UTC instead of local timezone\n          // Solution from: https://github.com/exceljs/exceljs/issues/486#issuecomment-432557582\n          // About Date.UTC(): https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Date/UTC#exemples\n          const date = api.getCellParams(id, column.field).value; // value may be `undefined` in auto-generated grouping rows\n\n          if (!date) {\n            break;\n          }\n\n          const utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));\n          row[column.field] = utcDate;\n          break;\n        }\n\n      case 'actions':\n        break;\n\n      default:\n        row[column.field] = api.getCellParams(id, column.field).formattedValue;\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (String(cellParams.formattedValue) === '[object Object]') {\n            warnInvalidFormattedValue();\n          }\n        }\n\n        break;\n    }\n  });\n  return {\n    row,\n    dataValidation,\n    outlineLevel,\n    mergedCells\n  };\n};\n\nconst defaultColumnsStyles = {\n  [GRID_DATE_COL_DEF.type]: {\n    numFmt: 'dd.mm.yyyy'\n  },\n  [GRID_DATETIME_COL_DEF.type]: {\n    numFmt: 'dd.mm.yyyy hh:mm'\n  }\n};\n\nconst serializeColumn = (column, columnsStyles) => {\n  const {\n    field,\n    type\n  } = column;\n  return {\n    key: field,\n    // Excel width must stay between 0 and 255 (https://support.microsoft.com/en-us/office/change-the-column-width-and-row-height-72f5e3cc-994d-43e8-ae58-9774a0905f46)\n    // From the example of column width behavior (https://docs.microsoft.com/en-US/office/troubleshoot/excel/determine-column-widths#example-of-column-width-behavior)\n    // a value of 10 corresponds to 75px. This is an approximation, because column width depends on the the font-size\n    width: Math.min(255, column.width ? column.width / 7.5 : 8.43),\n    style: _extends({}, type && (defaultColumnsStyles == null ? void 0 : defaultColumnsStyles[type]), columnsStyles == null ? void 0 : columnsStyles[field])\n  };\n};\n\nconst addColumnGroupingHeaders = (worksheet, columns, api) => {\n  const maxDepth = Math.max(...columns.map(_ref => {\n    let {\n      field\n    } = _ref;\n\n    var _api$unstable_getColu, _api$unstable_getColu2;\n\n    return (_api$unstable_getColu = (_api$unstable_getColu2 = api.unstable_getColumnGroupPath(field)) == null ? void 0 : _api$unstable_getColu2.length) != null ? _api$unstable_getColu : 0;\n  }));\n\n  if (maxDepth === 0) {\n    return;\n  }\n\n  const columnGroupDetails = api.unstable_getAllGroupDetails();\n\n  for (let rowIndex = 0; rowIndex < maxDepth; rowIndex += 1) {\n    const row = columns.map(_ref2 => {\n      let {\n        field\n      } = _ref2;\n      const groupingPath = api.unstable_getColumnGroupPath(field);\n\n      if (groupingPath.length <= rowIndex) {\n        return {\n          groupId: null,\n          parents: groupingPath\n        };\n      }\n\n      return _extends({}, columnGroupDetails[groupingPath[rowIndex]], {\n        parents: groupingPath.slice(0, rowIndex)\n      });\n    });\n    const newRow = worksheet.addRow(row.map(group => group.groupId === null ? null : (group == null ? void 0 : group.headerName) || group.groupId)); // use `rowCount`, since worksheet can have additional rows added in `exceljsPreProcess`\n\n    const lastRowIndex = newRow.worksheet.rowCount;\n    let leftIndex = 0;\n    let rightIndex = 1;\n\n    while (rightIndex < columns.length) {\n      const {\n        groupId: leftGroupId,\n        parents: leftParents\n      } = row[leftIndex];\n      const {\n        groupId: rightGroupId,\n        parents: rightParents\n      } = row[rightIndex];\n      const areInSameGroup = leftGroupId === rightGroupId && leftParents.length === rightParents.length && leftParents.every((leftParent, index) => rightParents[index] === leftParent);\n\n      if (areInSameGroup) {\n        rightIndex += 1;\n      } else {\n        if (rightIndex - leftIndex > 1) {\n          worksheet.mergeCells(lastRowIndex, leftIndex + 1, lastRowIndex, rightIndex);\n        }\n\n        leftIndex = rightIndex;\n        rightIndex += 1;\n      }\n    }\n\n    if (rightIndex - leftIndex > 1) {\n      worksheet.mergeCells(lastRowIndex, leftIndex + 1, lastRowIndex, rightIndex);\n    }\n  }\n};\n\nexport async function buildExcel(options, api) {\n  const {\n    columns,\n    rowIds,\n    includeHeaders,\n    includeColumnGroupsHeaders,\n    valueOptionsSheetName,\n    exceljsPreProcess,\n    exceljsPostProcess,\n    columnsStyles = {}\n  } = options;\n  const excelJS = await getExcelJs();\n  const workbook = new excelJS.Workbook();\n  const worksheet = workbook.addWorksheet('Sheet1');\n  worksheet.columns = columns.map(column => serializeColumn(column, columnsStyles));\n\n  if (exceljsPreProcess) {\n    await exceljsPreProcess({\n      workbook,\n      worksheet\n    });\n  }\n\n  if (includeColumnGroupsHeaders) {\n    addColumnGroupingHeaders(worksheet, columns, api);\n  }\n\n  if (includeHeaders) {\n    worksheet.addRow(columns.map(column => column.headerName || column.field));\n  }\n\n  const columnsWithArrayValueOptions = columns.filter(column => column.type === 'singleSelect' && column.valueOptions && typeof column.valueOptions !== 'function');\n  const defaultValueOptionsFormulae = {};\n\n  if (columnsWithArrayValueOptions.length) {\n    const valueOptionsWorksheet = workbook.addWorksheet(valueOptionsSheetName);\n    valueOptionsWorksheet.columns = columnsWithArrayValueOptions.map(_ref3 => {\n      let {\n        field\n      } = _ref3;\n      return {\n        key: field\n      };\n    });\n    columnsWithArrayValueOptions.forEach(column => {\n      const formattedValueOptions = getFormattedValueOptions(column, column.valueOptions, api);\n      valueOptionsWorksheet.getColumn(column.field).values = [column.headerName || column.field, ...formattedValueOptions];\n      const columnLetter = valueOptionsWorksheet.getColumn(column.field).letter;\n      defaultValueOptionsFormulae[column.field] = `${valueOptionsSheetName}!$${columnLetter}$2:$${columnLetter}$${1 + formattedValueOptions.length}`;\n    });\n  }\n\n  rowIds.forEach(id => {\n    const {\n      row,\n      dataValidation,\n      outlineLevel,\n      mergedCells\n    } = serializeRow(id, columns, api, defaultValueOptionsFormulae);\n    const newRow = worksheet.addRow(row);\n    Object.keys(dataValidation).forEach(field => {\n      newRow.getCell(field).dataValidation = _extends({}, dataValidation[field]);\n    });\n\n    if (outlineLevel) {\n      newRow.outlineLevel = outlineLevel;\n    } // use `rowCount`, since worksheet can have additional rows added in `exceljsPreProcess`\n\n\n    const lastRowIndex = newRow.worksheet.rowCount;\n    mergedCells.forEach(mergedCell => {\n      worksheet.mergeCells(lastRowIndex, mergedCell.leftIndex, lastRowIndex, mergedCell.rightIndex);\n    });\n  });\n\n  if (exceljsPostProcess) {\n    await exceljsPostProcess({\n      workbook,\n      worksheet\n    });\n  }\n\n  return workbook;\n}","map":null,"metadata":{},"sourceType":"module"}