{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport MuiDivider from '@mui/material/Divider';\nimport { gridColumnLookupSelector } from '@mui/x-data-grid-pro';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid-pro/internals';\nimport { getAvailableAggregationFunctions, addFooterRows, getAggregationRules, mergeStateWithAggregationModel } from './gridAggregationUtils';\nimport { wrapColumnWithAggregationValue, unwrapColumnFromAggregation } from './wrapColumnWithAggregation';\nimport { GridAggregationColumnMenuItem } from '../../../components/GridAggregationColumnMenuItem';\nimport { gridAggregationModelSelector } from './gridAggregationSelectors';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst Divider = () => /*#__PURE__*/_jsx(MuiDivider, {\n  onClick: event => event.stopPropagation()\n});\n\nexport const useGridAggregationPreProcessors = (apiRef, props) => {\n  const updateAggregatedColumns = React.useCallback(columnsState => {\n    const {\n      rulesOnLastColumnHydration\n    } = apiRef.current.unstable_caches.aggregation;\n    const aggregationRules = props.disableAggregation ? {} : getAggregationRules({\n      columnsLookup: columnsState.lookup,\n      aggregationModel: gridAggregationModelSelector(apiRef),\n      aggregationFunctions: props.aggregationFunctions\n    });\n    columnsState.all.forEach(field => {\n      const shouldHaveAggregationValue = !!aggregationRules[field];\n      const haveAggregationColumnValue = !!rulesOnLastColumnHydration[field];\n      let column = columnsState.lookup[field];\n\n      if (haveAggregationColumnValue) {\n        column = unwrapColumnFromAggregation({\n          column\n        });\n      }\n\n      if (shouldHaveAggregationValue) {\n        column = wrapColumnWithAggregationValue({\n          column,\n          aggregationRule: aggregationRules[field],\n          apiRef\n        });\n      }\n\n      columnsState.lookup[field] = column;\n    });\n    apiRef.current.unstable_caches.aggregation.rulesOnLastColumnHydration = aggregationRules;\n    return columnsState;\n  }, [apiRef, props.aggregationFunctions, props.disableAggregation]);\n  const addGroupFooterRows = React.useCallback(groupingParams => {\n    let newGroupingParams;\n    let rulesOnLastRowHydration;\n\n    if (props.disableAggregation) {\n      newGroupingParams = groupingParams;\n      rulesOnLastRowHydration = {};\n    } else {\n      const aggregationRules = getAggregationRules({\n        columnsLookup: gridColumnLookupSelector(apiRef),\n        aggregationModel: gridAggregationModelSelector(apiRef),\n        aggregationFunctions: props.aggregationFunctions\n      });\n      rulesOnLastRowHydration = aggregationRules; // If no column have an aggregation rule\n      // Then don't create the footer rows\n\n      if (Object.values(aggregationRules).length === 0) {\n        newGroupingParams = groupingParams;\n      } else {\n        newGroupingParams = addFooterRows({\n          groupingParams,\n          aggregationRules,\n          getAggregationPosition: props.getAggregationPosition,\n          apiRef\n        });\n      }\n    }\n\n    apiRef.current.unstable_caches.aggregation.rulesOnLastRowHydration = rulesOnLastRowHydration;\n    return newGroupingParams;\n  }, [apiRef, props.disableAggregation, props.getAggregationPosition, props.aggregationFunctions]);\n  const addColumnMenuButtons = React.useCallback((initialValue, column) => {\n    if (props.disableAggregation) {\n      return initialValue;\n    }\n\n    const availableAggregationFunctions = getAvailableAggregationFunctions({\n      aggregationFunctions: props.aggregationFunctions,\n      column\n    });\n\n    if (availableAggregationFunctions.length === 0) {\n      return initialValue;\n    }\n\n    return [...initialValue, /*#__PURE__*/_jsx(Divider, {}), /*#__PURE__*/_jsx(GridAggregationColumnMenuItem, {\n      column: column,\n      label: apiRef.current.getLocaleText('aggregationMenuItemHeader'),\n      availableAggregationFunctions: availableAggregationFunctions\n    })];\n  }, [apiRef, props.aggregationFunctions, props.disableAggregation]);\n  const stateExportPreProcessing = React.useCallback(prevState => {\n    if (props.disableAggregation) {\n      return prevState;\n    }\n\n    const aggregationModelToExport = gridAggregationModelSelector(apiRef);\n\n    if (Object.values(aggregationModelToExport).length === 0) {\n      return prevState;\n    }\n\n    return _extends({}, prevState, {\n      aggregation: {\n        model: aggregationModelToExport\n      }\n    });\n  }, [apiRef, props.disableAggregation]);\n  const stateRestorePreProcessing = React.useCallback((params, context) => {\n    var _context$stateToResto;\n\n    if (props.disableAggregation) {\n      return params;\n    }\n\n    const aggregationModel = (_context$stateToResto = context.stateToRestore.aggregation) == null ? void 0 : _context$stateToResto.model;\n\n    if (aggregationModel != null) {\n      apiRef.current.setState(mergeStateWithAggregationModel(aggregationModel));\n    }\n\n    return params;\n  }, [apiRef, props.disableAggregation]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateColumns', updateAggregatedColumns);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addGroupFooterRows);\n  useGridRegisterPipeProcessor(apiRef, 'columnMenu', addColumnMenuButtons);\n  useGridRegisterPipeProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n};","map":null,"metadata":{},"sourceType":"module"}