{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { passFilterLogic } from '@mui/x-data-grid-pro/internals';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nexport const GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD = '__row_group_by_columns_group__';\nexport const ROW_GROUPING_STRATEGY = 'grouping-columns';\nexport const getRowGroupingFieldFromGroupingCriteria = groupingCriteria => {\n  if (groupingCriteria === null) {\n    return GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD;\n  }\n\n  return `__row_group_by_columns_group_${groupingCriteria}__`;\n};\nexport const getRowGroupingCriteriaFromGroupingField = groupingColDefField => {\n  const match = groupingColDefField.match(/^__row_group_by_columns_group_(.*)__$/);\n\n  if (!match) {\n    return null;\n  }\n\n  return match[1];\n};\nexport const isGroupingColumn = field => field === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD || getRowGroupingCriteriaFromGroupingField(field) !== null;\n/**\n * When filtering a group, we only want to filter according to the items related to this grouping column.\n */\n\nconst shouldApplyFilterItemOnGroup = (columnField, node) => {\n  if (columnField === GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD) {\n    return true;\n  }\n\n  const groupingCriteriaField = getRowGroupingCriteriaFromGroupingField(columnField);\n  return groupingCriteriaField === node.groupingField;\n};\n/**\n * A leaf is visible if it passed the filter\n * A group is visible if all the following criteria are met:\n * - One of its children is passing the filter\n * - It is passing the filter\n */\n\n\nexport const filterRowTreeFromGroupingColumns = params => {\n  const {\n    rowTree,\n    isRowMatchingFilters,\n    filterModel\n  } = params;\n  const visibleRowsLookup = {};\n  const filteredRowsLookup = {};\n  const filteredDescendantCountLookup = {};\n\n  const filterTreeNode = (node, areAncestorsExpanded, ancestorsResults) => {\n    var _node$children;\n\n    let isPassingFiltering = false;\n    let filterResults = {\n      passingFilterItems: null,\n      passingQuickFilterValues: null\n    };\n\n    if (isRowMatchingFilters && node.position !== 'footer') {\n      const shouldApplyItem = node.isAutoGenerated ? columnField => shouldApplyFilterItemOnGroup(columnField, node) : undefined;\n      filterResults = isRowMatchingFilters(node.id, shouldApplyItem);\n    } else {\n      isPassingFiltering = true;\n    }\n\n    let filteredDescendantCount = 0;\n    (_node$children = node.children) == null ? void 0 : _node$children.forEach(childId => {\n      const childNode = rowTree[childId];\n      const childSubTreeSize = filterTreeNode(childNode, areAncestorsExpanded && !!node.childrenExpanded, [...ancestorsResults, filterResults]);\n      filteredDescendantCount += childSubTreeSize;\n    });\n\n    if (isPassingFiltering === false) {\n      var _node$children2;\n\n      if ((_node$children2 = node.children) != null && _node$children2.length) {\n        // If node has children - it's passing if at least one child passes filters\n        isPassingFiltering = filteredDescendantCount > 0;\n      } else {\n        const allResults = [...ancestorsResults, filterResults];\n        isPassingFiltering = passFilterLogic(allResults.map(result => result.passingFilterItems), allResults.map(result => result.passingQuickFilterValues), filterModel, params.apiRef);\n      }\n    }\n\n    visibleRowsLookup[node.id] = isPassingFiltering && areAncestorsExpanded;\n    filteredRowsLookup[node.id] = isPassingFiltering;\n\n    if (node.footerId != null) {\n      visibleRowsLookup[node.footerId] = isPassingFiltering && areAncestorsExpanded && !!node.childrenExpanded;\n    }\n\n    if (!isPassingFiltering) {\n      return 0;\n    }\n\n    filteredDescendantCountLookup[node.id] = filteredDescendantCount;\n\n    if (!node.children && !node.isAutoGenerated) {\n      return filteredDescendantCount + 1;\n    }\n\n    return filteredDescendantCount;\n  };\n\n  const nodes = Object.values(rowTree);\n\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n\n    if (node.depth === 0) {\n      filterTreeNode(node, true, []);\n    }\n  }\n\n  return {\n    visibleRowsLookup,\n    filteredRowsLookup,\n    filteredDescendantCountLookup\n  };\n};\nexport const getColDefOverrides = (groupingColDefProp, fields) => {\n  if (typeof groupingColDefProp === 'function') {\n    return groupingColDefProp({\n      groupingName: ROW_GROUPING_STRATEGY,\n      fields\n    });\n  }\n\n  return groupingColDefProp;\n};\nexport const mergeStateWithRowGroupingModel = rowGroupingModel => state => _extends({}, state, {\n  rowGrouping: _extends({}, state.rowGrouping, {\n    model: rowGroupingModel\n  })\n});\nexport const setStrategyAvailability = (apiRef, disableRowGrouping) => {\n  let isAvailable;\n\n  if (disableRowGrouping) {\n    isAvailable = () => false;\n  } else {\n    isAvailable = () => {\n      const rowGroupingSanitizedModel = gridRowGroupingSanitizedModelSelector(apiRef);\n      return rowGroupingSanitizedModel.length > 0;\n    };\n  }\n\n  apiRef.current.unstable_setStrategyAvailability('rowTree', ROW_GROUPING_STRATEGY, isAvailable);\n};\nexport const getGroupingRules = _ref => {\n  let {\n    sanitizedRowGroupingModel,\n    columnsLookup\n  } = _ref;\n  return sanitizedRowGroupingModel.map(field => {\n    var _columnsLookup$field;\n\n    return {\n      field,\n      groupingValueGetter: (_columnsLookup$field = columnsLookup[field]) == null ? void 0 : _columnsLookup$field.groupingValueGetter\n    };\n  });\n};\n/**\n * Compares two sets of grouping rules to determine if they are equal or not.\n */\n\nexport const areGroupingRulesEqual = function () {\n  let previousValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let newValue = arguments.length > 1 ? arguments[1] : undefined;\n\n  if (previousValue.length !== newValue.length) {\n    return false;\n  }\n\n  return newValue.every((newRule, newRuleIndex) => {\n    const previousRule = previousValue[newRuleIndex];\n\n    if (previousRule.groupingValueGetter !== newRule.groupingValueGetter) {\n      return false;\n    }\n\n    if (previousRule.field !== newRule.field) {\n      return false;\n    }\n\n    return true;\n  });\n};","map":null,"metadata":{},"sourceType":"module"}