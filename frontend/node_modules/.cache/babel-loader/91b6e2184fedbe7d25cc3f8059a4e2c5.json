{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { columnPinningStateInitializer } from './useGridColumnPinning';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nexport const useGridColumnPinningPreProcessors = (apiRef, props) => {\n  const {\n    disableColumnPinning,\n    pinnedColumns: pinnedColumnsProp,\n    initialState\n  } = props;\n  let pinnedColumns = gridPinnedColumnsSelector(apiRef.current.state);\n\n  if (pinnedColumns == null) {\n    // Since the state is not ready yet lets use the initializer to get which\n    // columns should be pinned initially.\n    const initializedState = columnPinningStateInitializer(apiRef.current.state, {\n      disableColumnPinning,\n      pinnedColumns: pinnedColumnsProp,\n      initialState\n    }, apiRef);\n    pinnedColumns = gridPinnedColumnsSelector(initializedState);\n  }\n\n  const prevAllPinnedColumns = React.useRef();\n  const reorderPinnedColumns = React.useCallback(columnsState => {\n    if (columnsState.all.length === 0 || disableColumnPinning) {\n      return columnsState;\n    }\n\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, columnsState.all);\n    let newOrderedFields;\n    const allPinnedColumns = [...leftPinnedColumns, ...rightPinnedColumns];\n    const {\n      orderedFieldsBeforePinningColumns\n    } = apiRef.current.unstable_caches.columnPinning;\n\n    if (orderedFieldsBeforePinningColumns) {\n      newOrderedFields = new Array(columnsState.all.length).fill(null);\n      const newOrderedFieldsBeforePinningColumns = [...newOrderedFields]; // Contains the fields not added to the orderedFields array yet\n\n      const remainingFields = [...columnsState.all]; // First, we check if the column was unpinned since the last processing.\n      // If yes and it still exists, we move it back to the same position it was before pinning\n\n      prevAllPinnedColumns.current.forEach(field => {\n        if (!allPinnedColumns.includes(field) && columnsState.lookup[field]) {\n          // Get the position before pinning\n          const index = orderedFieldsBeforePinningColumns.indexOf(field);\n          newOrderedFields[index] = field;\n          newOrderedFieldsBeforePinningColumns[index] = field; // This field was already consumed so we prevent from being added again\n\n          remainingFields.splice(remainingFields.indexOf(field), 1);\n        }\n      }); // For columns still pinned, we keep stored their original positions\n\n      allPinnedColumns.forEach(field => {\n        let index = orderedFieldsBeforePinningColumns.indexOf(field); // If index = -1, the pinned field didn't exist in the last processing, it's possibly being added now\n        // If index >= newOrderedFieldsBeforePinningColumns.length, then one or more columns were removed\n        // In both cases, use the position from the columns array\n        // TODO: detect removed columns and decrease the positions after it\n\n        if (index === -1 || index >= newOrderedFieldsBeforePinningColumns.length) {\n          index = columnsState.all.indexOf(field);\n        } // The fallback above may make the column to be inserted in a position already occupied\n        // In this case, put it in any empty slot available\n\n\n        if (newOrderedFieldsBeforePinningColumns[index] !== null) {\n          index = 0;\n\n          while (newOrderedFieldsBeforePinningColumns[index] !== null) {\n            index += 1;\n          }\n        }\n\n        newOrderedFields[index] = field;\n        newOrderedFieldsBeforePinningColumns[index] = field; // This field was already consumed so we prevent from being added again\n\n        remainingFields.splice(remainingFields.indexOf(field), 1);\n      }); // The fields remaining are those that're neither pinnned nor were unpinned\n      // For these, we spread them across both arrays making sure to not override existing values\n\n      let i = 0;\n      remainingFields.forEach(field => {\n        while (newOrderedFieldsBeforePinningColumns[i] !== null) {\n          i += 1;\n        }\n\n        newOrderedFieldsBeforePinningColumns[i] = field;\n        newOrderedFields[i] = field;\n      });\n      apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n    } else {\n      newOrderedFields = [...columnsState.all];\n      apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = [...columnsState.all];\n    }\n\n    prevAllPinnedColumns.current = allPinnedColumns;\n    const centerColumns = newOrderedFields.filter(field => {\n      return !leftPinnedColumns.includes(field) && !rightPinnedColumns.includes(field);\n    });\n    return _extends({}, columnsState, {\n      all: [...leftPinnedColumns, ...centerColumns, ...rightPinnedColumns]\n    });\n  }, [apiRef, disableColumnPinning, pinnedColumns]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateColumns', reorderPinnedColumns);\n};","map":null,"metadata":{},"sourceType":"module"}