{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"],\n      _excluded2 = [\"leafField\", \"mainGroupingCriteria\", \"hideDescendantCount\"];\nimport * as React from 'react';\nimport { GRID_STRING_COL_DEF } from '@mui/x-data-grid-pro';\nimport { GridGroupingColumnFooterCell } from '../../../components/GridGroupingColumnFooterCell';\nimport { GridGroupingCriteriaCell } from '../../../components/GridGroupingCriteriaCell';\nimport { GridGroupingColumnLeafCell } from '../../../components/GridGroupingColumnLeafCell';\nimport { getRowGroupingFieldFromGroupingCriteria, GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD } from './gridRowGroupingUtils';\nimport { gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst GROUPING_COL_DEF_DEFAULT_PROPERTIES = _extends({}, GRID_STRING_COL_DEF, {\n  disableReorder: true\n});\n\nconst GROUPING_COL_DEF_FORCED_PROPERTIES = {\n  type: 'rowGroupByColumnsGroup',\n  editable: false,\n  groupable: false\n};\n/**\n * When sorting two cells with different grouping criteria, we consider that the cell with the grouping criteria coming first in the model should be displayed below.\n * This can occur when some rows don't have all the fields. In which case we want the rows with the missing field to be displayed above.\n * TODO: Make this index comparator depth invariant, the logic should not be inverted when sorting in the \"desc\" direction (but the current return format of `sortComparator` does not support this behavior).\n */\n\nconst groupingFieldIndexComparator = (v1, v2, cellParams1, cellParams2) => {\n  const model = gridRowGroupingSanitizedModelSelector(cellParams1.api.state, cellParams1.api.instanceId);\n  const groupingField1 = cellParams1.rowNode.groupingField;\n  const groupingField2 = cellParams2.rowNode.groupingField;\n\n  if (groupingField1 === groupingField2) {\n    return 0;\n  }\n\n  if (groupingField1 == null) {\n    return -1;\n  }\n\n  if (groupingField2 == null) {\n    return 1;\n  }\n\n  if (model.indexOf(groupingField1) < model.indexOf(groupingField2)) {\n    return -1;\n  }\n\n  return 1;\n};\n\nconst getLeafProperties = leafColDef => {\n  var _leafColDef$headerNam, _leafColDef$filterOpe;\n\n  return {\n    headerName: (_leafColDef$headerNam = leafColDef.headerName) != null ? _leafColDef$headerNam : leafColDef.field,\n    sortable: leafColDef.sortable,\n    filterable: leafColDef.filterable,\n    filterOperators: (_leafColDef$filterOpe = leafColDef.filterOperators) == null ? void 0 : _leafColDef$filterOpe.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          return originalFn(params);\n        };\n      }\n    })),\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the leaves\n      if (cellParams1.rowNode.groupingField === null && cellParams2.rowNode.groupingField === null) {\n        return leafColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    }\n  };\n};\n\nconst getGroupingCriteriaProperties = (groupedByColDef, applyHeaderName) => {\n  var _groupedByColDef$filt;\n\n  const properties = {\n    sortable: groupedByColDef.sortable,\n    filterable: groupedByColDef.filterable,\n    sortComparator: (v1, v2, cellParams1, cellParams2) => {\n      // We only want to sort the groups of the current grouping criteria\n      if (cellParams1.rowNode.groupingField === groupedByColDef.field && cellParams2.rowNode.groupingField === groupedByColDef.field) {\n        return groupedByColDef.sortComparator(v1, v2, cellParams1, cellParams2);\n      }\n\n      return groupingFieldIndexComparator(v1, v2, cellParams1, cellParams2);\n    },\n    filterOperators: (_groupedByColDef$filt = groupedByColDef.filterOperators) == null ? void 0 : _groupedByColDef$filt.map(operator => _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          return originalFn(params);\n        };\n      }\n    }))\n  };\n\n  if (applyHeaderName) {\n    var _groupedByColDef$head;\n\n    properties.headerName = (_groupedByColDef$head = groupedByColDef.headerName) != null ? _groupedByColDef$head : groupedByColDef.field;\n  }\n\n  return properties;\n};\n/**\n * Creates the `GridColDef` for a grouping column that only takes care of a single grouping criteria\n */\n\n\nexport const createGroupingColDefForOneGroupingCriteria = _ref3 => {\n  let {\n    columnsLookup,\n    groupedByColDef,\n    groupingCriteria,\n    colDefOverride\n  } = _ref3;\n\n  var _groupedByColDef$widt, _leafColDef$width;\n\n  const _ref = colDefOverride != null ? colDefOverride : {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    width: Math.max(((_groupedByColDef$widt = groupedByColDef.width) != null ? _groupedByColDef$widt : GRID_STRING_COL_DEF.width) + 40, (_leafColDef$width = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.position === 'footer') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      } // Render leaves\n\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render current grouping criteria groups\n\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n          hideDescendantCount: hideDescendantCount\n        }));\n      }\n\n      return '';\n    },\n    valueGetter: params => {\n      if (!params.rowNode) {\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField === groupingCriteria) {\n        return params.rowNode.groupingKey;\n      }\n\n      return undefined;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching the `groupingCriteria`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedByColDef`.\n  // It can be useful to define a `leafField` for leaves rendering but still use the grouping criteria for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `groupedColDef`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && mainGroupingCriteria === groupingCriteria) {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(groupedByColDef, true);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: getRowGroupingFieldFromGroupingCriteria(groupingCriteria)\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};\n/**\n * Creates the `GridColDef` for a grouping column that takes care of all the grouping criteria\n */\n\nexport const createGroupingColDefForAllGroupingCriteria = _ref4 => {\n  let {\n    apiRef,\n    columnsLookup,\n    rowGroupingModel,\n    colDefOverride\n  } = _ref4;\n\n  var _leafColDef$width2;\n\n  const _ref2 = colDefOverride != null ? colDefOverride : {},\n        {\n    leafField,\n    mainGroupingCriteria,\n    hideDescendantCount\n  } = _ref2,\n        colDefOverrideProperties = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n\n  const leafColDef = leafField ? columnsLookup[leafField] : null; // The properties that do not depend on the presence of a `leafColDef` and that can be overridden by `colDefOverride`\n\n  const commonProperties = {\n    headerName: apiRef.current.getLocaleText('groupingColumnHeaderName'),\n    width: Math.max(...rowGroupingModel.map(field => {\n      var _columnsLookup$field$;\n\n      return ((_columnsLookup$field$ = columnsLookup[field].width) != null ? _columnsLookup$field$ : GRID_STRING_COL_DEF.width) + 40;\n    }), (_leafColDef$width2 = leafColDef == null ? void 0 : leafColDef.width) != null ? _leafColDef$width2 : 0),\n    renderCell: params => {\n      // Render footer\n      if (params.rowNode.position === 'footer') {\n        return /*#__PURE__*/_jsx(GridGroupingColumnFooterCell, _extends({}, params));\n      } // Render the leaves\n\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          const leafParams = _extends({}, params.api.getCellParams(params.id, leafField), {\n            api: params.api\n          });\n\n          if (leafColDef.renderCell) {\n            return leafColDef.renderCell(leafParams);\n          }\n\n          return /*#__PURE__*/_jsx(GridGroupingColumnLeafCell, _extends({}, leafParams));\n        }\n\n        return '';\n      } // Render the groups\n\n\n      return /*#__PURE__*/_jsx(GridGroupingCriteriaCell, _extends({}, params, {\n        hideDescendantCount: hideDescendantCount\n      }));\n    },\n    valueGetter: params => {\n      if (!params.rowNode) {\n        return undefined;\n      }\n\n      if (params.rowNode.groupingField == null) {\n        if (leafColDef) {\n          return params.api.getCellValue(params.id, leafField);\n        }\n\n        return undefined;\n      }\n\n      return params.rowNode.groupingKey;\n    }\n  }; // If we have a `mainGroupingCriteria` defined and matching one of the `orderedGroupedByFields`\n  // Then we apply the sorting / filtering on the groups of this column's grouping criteria based on the properties of `columnsLookup[mainGroupingCriteria]`.\n  // It can be useful to use another grouping criteria than the top level one for the sorting / filtering\n  //\n  // If we have a `leafField` defined and matching an existing column\n  // Then we apply the sorting / filtering on the leaves based on the properties of `leavesColDef`\n  //\n  // By default, we apply the sorting / filtering on the groups of the top level grouping criteria based on the properties of `columnsLookup[orderedGroupedByFields[0]]`.\n\n  let sourceProperties;\n\n  if (mainGroupingCriteria && rowGroupingModel.includes(mainGroupingCriteria)) {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[mainGroupingCriteria], true);\n  } else if (leafColDef) {\n    sourceProperties = getLeafProperties(leafColDef);\n  } else {\n    sourceProperties = getGroupingCriteriaProperties(columnsLookup[rowGroupingModel[0]], rowGroupingModel.length === 1);\n  } // The properties that can't be overridden with `colDefOverride`\n\n\n  const forcedProperties = _extends({\n    field: GRID_ROW_GROUPING_SINGLE_GROUPING_FIELD\n  }, GROUPING_COL_DEF_FORCED_PROPERTIES);\n\n  return _extends({}, GROUPING_COL_DEF_DEFAULT_PROPERTIES, commonProperties, sourceProperties, colDefOverrideProperties, forcedProperties);\n};","map":null,"metadata":{},"sourceType":"module"}