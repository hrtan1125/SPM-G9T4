{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { capitalize } from '@mui/material';\nimport { addPinnedRow, isDeepEqual } from '@mui/x-data-grid-pro/internals';\nexport const GRID_AGGREGATION_ROOT_FOOTER_ROW_ID = 'auto-generated-group-footer-root';\nexport const getAggregationFooterRowIdFromGroupId = groupId => {\n  if (groupId == null) {\n    return GRID_AGGREGATION_ROOT_FOOTER_ROW_ID;\n  }\n\n  return `auto-generated-group-footer-${groupId}`;\n};\nexport const canColumnHaveAggregationFunction = _ref => {\n  let {\n    column,\n    aggregationFunctionName,\n    aggregationFunction\n  } = _ref;\n\n  if (!column || !column.aggregable) {\n    return false;\n  }\n\n  if (!aggregationFunction) {\n    return false;\n  }\n\n  if (column.availableAggregationFunctions != null) {\n    return column.availableAggregationFunctions.includes(aggregationFunctionName);\n  }\n\n  if (!aggregationFunction.columnTypes) {\n    return true;\n  }\n\n  return aggregationFunction.columnTypes.includes(column.type);\n};\nexport const getAvailableAggregationFunctions = _ref2 => {\n  let {\n    aggregationFunctions,\n    column\n  } = _ref2;\n  return Object.keys(aggregationFunctions).filter(aggregationFunctionName => canColumnHaveAggregationFunction({\n    column,\n    aggregationFunctionName,\n    aggregationFunction: aggregationFunctions[aggregationFunctionName]\n  }));\n};\nexport const mergeStateWithAggregationModel = aggregationModel => state => _extends({}, state, {\n  aggregation: _extends({}, state.aggregation, {\n    model: aggregationModel\n  })\n});\nexport const getAggregationRules = _ref3 => {\n  let {\n    columnsLookup,\n    aggregationModel,\n    aggregationFunctions\n  } = _ref3;\n  const aggregationRules = {};\n  Object.entries(aggregationModel).forEach(_ref4 => {\n    let [field, columnItem] = _ref4;\n\n    if (columnsLookup[field] && canColumnHaveAggregationFunction({\n      column: columnsLookup[field],\n      aggregationFunctionName: columnItem,\n      aggregationFunction: aggregationFunctions[columnItem]\n    })) {\n      aggregationRules[field] = {\n        aggregationFunctionName: columnItem,\n        aggregationFunction: aggregationFunctions[columnItem]\n      };\n    }\n  });\n  return aggregationRules;\n};\n/**\n * Add a footer for each group that has at least one column with an aggregated value.\n */\n\nexport const addFooterRows = _ref5 => {\n  let {\n    groupingParams,\n    aggregationRules,\n    getAggregationPosition,\n    apiRef\n  } = _ref5;\n\n  if (Object.keys(aggregationRules).length === 0) {\n    return groupingParams;\n  }\n\n  const ids = [...groupingParams.ids];\n\n  const idRowsLookup = _extends({}, groupingParams.idRowsLookup);\n\n  const tree = _extends({}, groupingParams.tree);\n\n  const addGroupFooter = groupNode => {\n    var _groupNode$id;\n\n    const groupId = (_groupNode$id = groupNode == null ? void 0 : groupNode.id) != null ? _groupNode$id : null;\n\n    if (getAggregationPosition(groupNode) !== 'footer') {\n      return;\n    }\n\n    const footerId = getAggregationFooterRowIdFromGroupId(groupId);\n    ids.push(footerId);\n    idRowsLookup[footerId] = {};\n    tree[footerId] = {\n      id: footerId,\n      isAutoGenerated: true,\n      parent: groupId,\n      depth: groupNode ? groupNode.depth + 1 : 0,\n      groupingKey: null,\n      groupingField: null,\n      position: 'footer'\n    };\n\n    if (groupId != null) {\n      tree[groupId] = _extends({}, tree[groupId], {\n        footerId\n      });\n    }\n  }; // If the tree is flat, we don't need to loop through the rows\n\n\n  if (groupingParams.treeDepth > 1) {\n    groupingParams.ids.forEach(parentId => {\n      const parentNode = tree[parentId];\n\n      if (parentNode.depth === groupingParams.treeDepth - 1) {\n        return;\n      }\n\n      addGroupFooter(parentNode);\n    });\n  }\n\n  let newGroupingParams = _extends({}, groupingParams, {\n    tree,\n    idRowsLookup,\n    ids\n  });\n\n  if (getAggregationPosition(null) === 'footer') {\n    newGroupingParams = addPinnedRow({\n      groupingParams: newGroupingParams,\n      rowModel: {},\n      rowId: getAggregationFooterRowIdFromGroupId(null),\n      position: 'bottom',\n      apiRef\n    });\n  }\n\n  return _extends({}, groupingParams, newGroupingParams);\n};\n/**\n * Compares two sets of aggregation rules to determine if they are equal or not.\n */\n\nexport const areAggregationRulesEqual = (previousValue, newValue) => {\n  const previousFields = Object.keys(previousValue != null ? previousValue : {});\n  const newFields = Object.keys(newValue);\n\n  if (!isDeepEqual(previousFields, newFields)) {\n    return false;\n  }\n\n  return newFields.every(field => {\n    const previousRule = previousValue == null ? void 0 : previousValue[field];\n    const newRule = newValue[field];\n\n    if ((previousRule == null ? void 0 : previousRule.aggregationFunction) !== (newRule == null ? void 0 : newRule.aggregationFunction)) {\n      return false;\n    }\n\n    if ((previousRule == null ? void 0 : previousRule.aggregationFunctionName) !== (newRule == null ? void 0 : newRule.aggregationFunctionName)) {\n      return false;\n    }\n\n    return true;\n  });\n};\nexport const getAggregationFunctionLabel = _ref6 => {\n  let {\n    apiRef,\n    aggregationRule\n  } = _ref6;\n\n  if (aggregationRule.aggregationFunction.label != null) {\n    return aggregationRule.aggregationFunction.label;\n  }\n\n  try {\n    return apiRef.current.getLocaleText(`aggregationFunctionLabel${capitalize(aggregationRule.aggregationFunctionName)}`);\n  } catch (e) {\n    return aggregationRule.aggregationFunctionName;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}