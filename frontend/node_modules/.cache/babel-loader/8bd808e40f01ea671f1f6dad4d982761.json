{"ast":null,"code":"const perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;\nconst hasAbortController = typeof AbortController === 'function'; // minimal backwards-compatibility polyfill\n// this doesn't have nearly all the checks and whatnot that\n// actual AbortController/Signal has, but it's enough for\n// our purposes, and if used properly, behaves the same.\n\nconst AC = hasAbortController ? AbortController : class AbortController {\n  constructor() {\n    this.signal = new AS();\n  }\n\n  abort() {\n    this.signal.dispatchEvent('abort');\n  }\n\n};\nconst hasAbortSignal = typeof AbortSignal === 'function'; // Some polyfills put this on the AC class, not global\n\nconst hasACAbortSignal = typeof AC.AbortSignal === 'function';\nconst AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {\n  constructor() {\n    this.aborted = false;\n    this._listeners = [];\n  }\n\n  dispatchEvent(type) {\n    if (type === 'abort') {\n      this.aborted = true;\n      const e = {\n        type,\n        target: this\n      };\n      this.onabort(e);\n\n      this._listeners.forEach(f => f(e), this);\n    }\n  }\n\n  onabort() {}\n\n  addEventListener(ev, fn) {\n    if (ev === 'abort') {\n      this._listeners.push(fn);\n    }\n  }\n\n  removeEventListener(ev, fn) {\n    if (ev === 'abort') {\n      this._listeners = this._listeners.filter(f => f !== fn);\n    }\n  }\n\n};\nconst warned = new Set();\n\nconst deprecatedOption = (opt, instead) => {\n  const code = `LRU_CACHE_OPTION_${opt}`;\n\n  if (shouldWarn(code)) {\n    warn(code, `${opt} option`, `options.${instead}`, LRUCache);\n  }\n};\n\nconst deprecatedMethod = (method, instead) => {\n  const code = `LRU_CACHE_METHOD_${method}`;\n\n  if (shouldWarn(code)) {\n    const {\n      prototype\n    } = LRUCache;\n    const {\n      get\n    } = Object.getOwnPropertyDescriptor(prototype, method);\n    warn(code, `${method} method`, `cache.${instead}()`, get);\n  }\n};\n\nconst deprecatedProperty = (field, instead) => {\n  const code = `LRU_CACHE_PROPERTY_${field}`;\n\n  if (shouldWarn(code)) {\n    const {\n      prototype\n    } = LRUCache;\n    const {\n      get\n    } = Object.getOwnPropertyDescriptor(prototype, field);\n    warn(code, `${field} property`, `cache.${instead}`, get);\n  }\n};\n\nconst emitWarning = function () {\n  typeof process === 'object' && process && typeof process.emitWarning === 'function' ? process.emitWarning(...arguments) : console.error(...arguments);\n};\n\nconst shouldWarn = code => !warned.has(code);\n\nconst warn = (code, what, instead, fn) => {\n  warned.add(code);\n  const msg = `The ${what} is deprecated. Please use ${instead} instead.`;\n  emitWarning(msg, 'DeprecationWarning', code, fn);\n};\n\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */\n\n\nconst getUintArray = max => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size);\n    this.fill(0);\n  }\n\n}\n\nclass Stack {\n  constructor(max) {\n    if (max === 0) {\n      return [];\n    }\n\n    const UintArray = getUintArray(max);\n    this.heap = new UintArray(max);\n    this.length = 0;\n  }\n\n  push(n) {\n    this.heap[this.length++] = n;\n  }\n\n  pop() {\n    return this.heap[--this.length];\n  }\n\n}\n\nclass LRUCache {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      fetchContext,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet\n    } = options; // deprecated options, don't trigger a warning for getting them if\n    // the thing being passed in is another LRUCache we're copying.\n\n    const {\n      length,\n      maxAge,\n      stale\n    } = options instanceof LRUCache ? {} : options;\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer');\n    }\n\n    const UintArray = max ? getUintArray(max) : Array;\n\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max);\n    }\n\n    this.max = max;\n    this.maxSize = maxSize;\n    this.maxEntrySize = maxEntrySize || this.maxSize;\n    this.sizeCalculation = sizeCalculation || length;\n\n    if (this.sizeCalculation) {\n      if (!this.maxSize && !this.maxEntrySize) {\n        throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n      }\n\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function');\n      }\n    }\n\n    this.fetchMethod = fetchMethod || null;\n\n    if (this.fetchMethod && typeof this.fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified');\n    }\n\n    this.fetchContext = fetchContext;\n\n    if (!this.fetchMethod && fetchContext !== undefined) {\n      throw new TypeError('cannot set fetchContext without fetchMethod');\n    }\n\n    this.keyMap = new Map();\n    this.keyList = new Array(max).fill(null);\n    this.valList = new Array(max).fill(null);\n    this.next = new UintArray(max);\n    this.prev = new UintArray(max);\n    this.head = 0;\n    this.tail = 0;\n    this.free = new Stack(max);\n    this.initialFill = 1;\n    this.size = 0;\n\n    if (typeof dispose === 'function') {\n      this.dispose = dispose;\n    }\n\n    if (typeof disposeAfter === 'function') {\n      this.disposeAfter = disposeAfter;\n      this.disposed = [];\n    } else {\n      this.disposeAfter = null;\n      this.disposed = null;\n    }\n\n    this.noDisposeOnSet = !!noDisposeOnSet;\n    this.noUpdateTTL = !!noUpdateTTL;\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection; // NB: maxEntrySize is set to maxSize if it's set\n\n    if (this.maxEntrySize !== 0) {\n      if (this.maxSize !== 0) {\n        if (!isPosInt(this.maxSize)) {\n          throw new TypeError('maxSize must be a positive integer if specified');\n        }\n      }\n\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError('maxEntrySize must be a positive integer if specified');\n      }\n\n      this.initializeSizeTracking();\n    }\n\n    this.allowStale = !!allowStale || !!stale;\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n    this.updateAgeOnGet = !!updateAgeOnGet;\n    this.updateAgeOnHas = !!updateAgeOnHas;\n    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n    this.ttlAutopurge = !!ttlAutopurge;\n    this.ttl = ttl || maxAge || 0;\n\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified');\n      }\n\n      this.initializeTTLTracking();\n    } // do not allow completely unbounded caches\n\n\n    if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n      throw new TypeError('At least one of max, maxSize, or ttl is required');\n    }\n\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED';\n\n      if (shouldWarn(code)) {\n        warned.add(code);\n        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n      }\n    }\n\n    if (stale) {\n      deprecatedOption('stale', 'allowStale');\n    }\n\n    if (maxAge) {\n      deprecatedOption('maxAge', 'ttl');\n    }\n\n    if (length) {\n      deprecatedOption('length', 'sizeCalculation');\n    }\n  }\n\n  getRemainingTTL(key) {\n    return this.has(key, {\n      updateAgeOnHas: false\n    }) ? Infinity : 0;\n  }\n\n  initializeTTLTracking() {\n    var _this = this;\n\n    this.ttls = new ZeroArray(this.max);\n    this.starts = new ZeroArray(this.max);\n\n    this.setItemTTL = function (index, ttl) {\n      let start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : perf.now();\n      _this.starts[index] = ttl !== 0 ? start : 0;\n      _this.ttls[index] = ttl;\n\n      if (ttl !== 0 && _this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (_this.isStale(index)) {\n            _this.delete(_this.keyList[index]);\n          }\n        }, ttl + 1);\n        /* istanbul ignore else - unref() not supported on all platforms */\n\n        if (t.unref) {\n          t.unref();\n        }\n      }\n    };\n\n    this.updateItemAge = index => {\n      this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;\n    }; // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n\n\n    let cachedNow = 0;\n\n    const getNow = () => {\n      const n = perf.now();\n\n      if (this.ttlResolution > 0) {\n        cachedNow = n;\n        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);\n        /* istanbul ignore else - not available on all platforms */\n\n        if (t.unref) {\n          t.unref();\n        }\n      }\n\n      return n;\n    };\n\n    this.getRemainingTTL = key => {\n      const index = this.keyMap.get(key);\n\n      if (index === undefined) {\n        return 0;\n      }\n\n      return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());\n    };\n\n    this.isStale = index => {\n      return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];\n    };\n  }\n\n  updateItemAge(index) {}\n\n  setItemTTL(index, ttl, start) {}\n\n  isStale(index) {\n    return false;\n  }\n\n  initializeSizeTracking() {\n    this.calculatedSize = 0;\n    this.sizes = new ZeroArray(this.max);\n\n    this.removeItemSize = index => {\n      this.calculatedSize -= this.sizes[index];\n      this.sizes[index] = 0;\n    };\n\n    this.requireSize = (k, v, size, sizeCalculation) => {\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function');\n          }\n\n          size = sizeCalculation(v, k);\n\n          if (!isPosInt(size)) {\n            throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n          }\n        } else {\n          throw new TypeError('invalid size value (must be positive integer)');\n        }\n      }\n\n      return size;\n    };\n\n    this.addItemSize = (index, size) => {\n      this.sizes[index] = size;\n      const maxSize = this.maxSize - this.sizes[index];\n\n      while (this.calculatedSize > maxSize) {\n        this.evict(true);\n      }\n\n      this.calculatedSize += this.sizes[index];\n    };\n  }\n\n  removeItemSize(index) {}\n\n  addItemSize(index, size) {}\n\n  requireSize(k, v, size, sizeCalculation) {\n    if (size || sizeCalculation) {\n      throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n    }\n  }\n\n  *indexes() {\n    let {\n      allowStale = this.allowStale\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.size) {\n      for (let i = this.tail; true;) {\n        if (!this.isValidIndex(i)) {\n          break;\n        }\n\n        if (allowStale || !this.isStale(i)) {\n          yield i;\n        }\n\n        if (i === this.head) {\n          break;\n        } else {\n          i = this.prev[i];\n        }\n      }\n    }\n  }\n\n  *rindexes() {\n    let {\n      allowStale = this.allowStale\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.size) {\n      for (let i = this.head; true;) {\n        if (!this.isValidIndex(i)) {\n          break;\n        }\n\n        if (allowStale || !this.isStale(i)) {\n          yield i;\n        }\n\n        if (i === this.tail) {\n          break;\n        } else {\n          i = this.next[i];\n        }\n      }\n    }\n  }\n\n  isValidIndex(index) {\n    return this.keyMap.get(this.keyList[index]) === index;\n  }\n\n  *entries() {\n    for (const i of this.indexes()) {\n      yield [this.keyList[i], this.valList[i]];\n    }\n  }\n\n  *rentries() {\n    for (const i of this.rindexes()) {\n      yield [this.keyList[i], this.valList[i]];\n    }\n  }\n\n  *keys() {\n    for (const i of this.indexes()) {\n      yield this.keyList[i];\n    }\n  }\n\n  *rkeys() {\n    for (const i of this.rindexes()) {\n      yield this.keyList[i];\n    }\n  }\n\n  *values() {\n    for (const i of this.indexes()) {\n      yield this.valList[i];\n    }\n  }\n\n  *rvalues() {\n    for (const i of this.rindexes()) {\n      yield this.valList[i];\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  find(fn) {\n    let getOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (const i of this.indexes()) {\n      if (fn(this.valList[i], this.keyList[i], this)) {\n        return this.get(this.keyList[i], getOptions);\n      }\n    }\n  }\n\n  forEach(fn) {\n    let thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\n    for (const i of this.indexes()) {\n      fn.call(thisp, this.valList[i], this.keyList[i], this);\n    }\n  }\n\n  rforEach(fn) {\n    let thisp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\n    for (const i of this.rindexes()) {\n      fn.call(thisp, this.valList[i], this.keyList[i], this);\n    }\n  }\n\n  get prune() {\n    deprecatedMethod('prune', 'purgeStale');\n    return this.purgeStale;\n  }\n\n  purgeStale() {\n    let deleted = false;\n\n    for (const i of this.rindexes({\n      allowStale: true\n    })) {\n      if (this.isStale(i)) {\n        this.delete(this.keyList[i]);\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  dump() {\n    const arr = [];\n\n    for (const i of this.indexes({\n      allowStale: true\n    })) {\n      const key = this.keyList[i];\n      const v = this.valList[i];\n      const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n      const entry = {\n        value\n      };\n\n      if (this.ttls) {\n        entry.ttl = this.ttls[i]; // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n\n        const age = perf.now() - this.starts[i];\n        entry.start = Math.floor(Date.now() - age);\n      }\n\n      if (this.sizes) {\n        entry.size = this.sizes[i];\n      }\n\n      arr.unshift([key, entry]);\n    }\n\n    return arr;\n  }\n\n  load(arr) {\n    this.clear();\n\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset.\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start;\n        entry.start = perf.now() - age;\n      }\n\n      this.set(key, entry.value, entry);\n    }\n  }\n\n  dispose(v, k, reason) {}\n\n  set(k, v) {\n    let {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    size = this.requireSize(k, v, size, sizeCalculation); // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      return this;\n    }\n\n    let index = this.size === 0 ? undefined : this.keyMap.get(k);\n\n    if (index === undefined) {\n      // addition\n      index = this.newIndex();\n      this.keyList[index] = k;\n      this.valList[index] = v;\n      this.keyMap.set(k, index);\n      this.next[this.tail] = index;\n      this.prev[index] = this.tail;\n      this.tail = index;\n      this.size++;\n      this.addItemSize(index, size);\n      noUpdateTTL = false;\n    } else {\n      // update\n      const oldVal = this.valList[index];\n\n      if (v !== oldVal) {\n        if (this.isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort();\n        } else {\n          if (!noDisposeOnSet) {\n            this.dispose(oldVal, k, 'set');\n\n            if (this.disposeAfter) {\n              this.disposed.push([oldVal, k, 'set']);\n            }\n          }\n        }\n\n        this.removeItemSize(index);\n        this.valList[index] = v;\n        this.addItemSize(index, size);\n      }\n\n      this.moveToTail(index);\n    }\n\n    if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n      this.initializeTTLTracking();\n    }\n\n    if (!noUpdateTTL) {\n      this.setItemTTL(index, ttl, start);\n    }\n\n    if (this.disposeAfter) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n\n    return this;\n  }\n\n  newIndex() {\n    if (this.size === 0) {\n      return this.tail;\n    }\n\n    if (this.size === this.max && this.max !== 0) {\n      return this.evict(false);\n    }\n\n    if (this.free.length !== 0) {\n      return this.free.pop();\n    } // initial fill, just keep writing down the list\n\n\n    return this.initialFill++;\n  }\n\n  pop() {\n    if (this.size) {\n      const val = this.valList[this.head];\n      this.evict(true);\n      return val;\n    }\n  }\n\n  evict(free) {\n    const head = this.head;\n    const k = this.keyList[head];\n    const v = this.valList[head];\n\n    if (this.isBackgroundFetch(v)) {\n      v.__abortController.abort();\n    } else {\n      this.dispose(v, k, 'evict');\n\n      if (this.disposeAfter) {\n        this.disposed.push([v, k, 'evict']);\n      }\n    }\n\n    this.removeItemSize(head); // if we aren't about to use the index, then null these out\n\n    if (free) {\n      this.keyList[head] = null;\n      this.valList[head] = null;\n      this.free.push(head);\n    }\n\n    this.head = this.next[head];\n    this.keyMap.delete(k);\n    this.size--;\n    return head;\n  }\n\n  has(k) {\n    let {\n      updateAgeOnHas = this.updateAgeOnHas\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.keyMap.get(k);\n\n    if (index !== undefined) {\n      if (!this.isStale(index)) {\n        if (updateAgeOnHas) {\n          this.updateItemAge(index);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  } // like get(), but without any LRU updating or TTL expiration\n\n\n  peek(k) {\n    let {\n      allowStale = this.allowStale\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.keyMap.get(k);\n\n    if (index !== undefined && (allowStale || !this.isStale(index))) {\n      const v = this.valList[index]; // either stale and allowed, or forcing a refresh of non-stale value\n\n      return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n  }\n\n  backgroundFetch(k, index, options, context) {\n    const v = index === undefined ? undefined : this.valList[index];\n\n    if (this.isBackgroundFetch(v)) {\n      return v;\n    }\n\n    const ac = new AC();\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context\n    };\n\n    const cb = v => {\n      if (!ac.signal.aborted) {\n        this.set(k, v, fetchOpts.options);\n      }\n\n      return v;\n    };\n\n    const eb = er => {\n      if (this.valList[index] === p) {\n        const del = !options.noDeleteOnFetchRejection || p.__staleWhileFetching === undefined;\n\n        if (del) {\n          this.delete(k);\n        } else {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          this.valList[index] = p.__staleWhileFetching;\n        }\n      }\n\n      if (p.__returned === p) {\n        throw er;\n      }\n    };\n\n    const pcall = res => res(this.fetchMethod(k, v, fetchOpts));\n\n    const p = new Promise(pcall).then(cb, eb);\n    p.__abortController = ac;\n    p.__staleWhileFetching = v;\n    p.__returned = null;\n\n    if (index === undefined) {\n      this.set(k, p, fetchOpts.options);\n      index = this.keyMap.get(k);\n    } else {\n      this.valList[index] = p;\n    }\n\n    return p;\n  }\n\n  isBackgroundFetch(p) {\n    return p && typeof p === 'object' && typeof p.then === 'function' && Object.prototype.hasOwnProperty.call(p, '__staleWhileFetching') && Object.prototype.hasOwnProperty.call(p, '__returned') && (p.__returned === p || p.__returned === null);\n  } // this takes the union of get() and set() opts, because it does both\n\n\n  async fetch(k) {\n    let {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      fetchContext = this.fetchContext,\n      forceRefresh = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this.fetchMethod) {\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet\n      });\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection\n    };\n    let index = this.keyMap.get(k);\n\n    if (index === undefined) {\n      const p = this.backgroundFetch(k, index, options, fetchContext);\n      return p.__returned = p;\n    } else {\n      // in cache, maybe already fetching\n      const v = this.valList[index];\n\n      if (this.isBackgroundFetch(v)) {\n        return allowStale && v.__staleWhileFetching !== undefined ? v.__staleWhileFetching : v.__returned = v;\n      } // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n\n\n      if (!forceRefresh && !this.isStale(index)) {\n        this.moveToTail(index);\n\n        if (updateAgeOnGet) {\n          this.updateItemAge(index);\n        }\n\n        return v;\n      } // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n\n\n      const p = this.backgroundFetch(k, index, options, fetchContext);\n      return allowStale && p.__staleWhileFetching !== undefined ? p.__staleWhileFetching : p.__returned = p;\n    }\n  }\n\n  get(k) {\n    let {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.keyMap.get(k);\n\n    if (index !== undefined) {\n      const value = this.valList[index];\n      const fetching = this.isBackgroundFetch(value);\n\n      if (this.isStale(index)) {\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k);\n          }\n\n          return allowStale ? value : undefined;\n        } else {\n          return allowStale ? value.__staleWhileFetching : undefined;\n        }\n      } else {\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching,\n        // so we just return undefined\n        if (fetching) {\n          return undefined;\n        }\n\n        this.moveToTail(index);\n\n        if (updateAgeOnGet) {\n          this.updateItemAge(index);\n        }\n\n        return value;\n      }\n    }\n  }\n\n  connect(p, n) {\n    this.prev[n] = p;\n    this.next[p] = n;\n  }\n\n  moveToTail(index) {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.tail) {\n      if (index === this.head) {\n        this.head = this.next[index];\n      } else {\n        this.connect(this.prev[index], this.next[index]);\n      }\n\n      this.connect(this.tail, index);\n      this.tail = index;\n    }\n  }\n\n  get del() {\n    deprecatedMethod('del', 'delete');\n    return this.delete;\n  }\n\n  delete(k) {\n    let deleted = false;\n\n    if (this.size !== 0) {\n      const index = this.keyMap.get(k);\n\n      if (index !== undefined) {\n        deleted = true;\n\n        if (this.size === 1) {\n          this.clear();\n        } else {\n          this.removeItemSize(index);\n          const v = this.valList[index];\n\n          if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort();\n          } else {\n            this.dispose(v, k, 'delete');\n\n            if (this.disposeAfter) {\n              this.disposed.push([v, k, 'delete']);\n            }\n          }\n\n          this.keyMap.delete(k);\n          this.keyList[index] = null;\n          this.valList[index] = null;\n\n          if (index === this.tail) {\n            this.tail = this.prev[index];\n          } else if (index === this.head) {\n            this.head = this.next[index];\n          } else {\n            this.next[this.prev[index]] = this.next[index];\n            this.prev[this.next[index]] = this.prev[index];\n          }\n\n          this.size--;\n          this.free.push(index);\n        }\n      }\n    }\n\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n\n    return deleted;\n  }\n\n  clear() {\n    for (const index of this.rindexes({\n      allowStale: true\n    })) {\n      const v = this.valList[index];\n\n      if (this.isBackgroundFetch(v)) {\n        v.__abortController.abort();\n      } else {\n        const k = this.keyList[index];\n        this.dispose(v, k, 'delete');\n\n        if (this.disposeAfter) {\n          this.disposed.push([v, k, 'delete']);\n        }\n      }\n    }\n\n    this.keyMap.clear();\n    this.valList.fill(null);\n    this.keyList.fill(null);\n\n    if (this.ttls) {\n      this.ttls.fill(0);\n      this.starts.fill(0);\n    }\n\n    if (this.sizes) {\n      this.sizes.fill(0);\n    }\n\n    this.head = 0;\n    this.tail = 0;\n    this.initialFill = 1;\n    this.free.length = 0;\n    this.calculatedSize = 0;\n    this.size = 0;\n\n    if (this.disposed) {\n      while (this.disposed.length) {\n        this.disposeAfter(...this.disposed.shift());\n      }\n    }\n  }\n\n  get reset() {\n    deprecatedMethod('reset', 'clear');\n    return this.clear;\n  }\n\n  get length() {\n    deprecatedProperty('length', 'size');\n    return this.size;\n  }\n\n  static get AbortController() {\n    return AC;\n  }\n\n  static get AbortSignal() {\n    return AS;\n  }\n\n}\n\nmodule.exports = LRUCache;","map":null,"metadata":{},"sourceType":"script"}