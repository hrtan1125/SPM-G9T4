{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { gridAggregationLookupSelector } from './gridAggregationSelectors';\nimport { GridFooterCell } from '../../../components/GridFooterCell';\nimport { GridAggregationHeader } from '../../../components/GridAggregationHeader';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\n\nconst getAggregationValueWrappedValueGetter = _ref => {\n  let {\n    value: valueGetter,\n    getCellAggregationResult\n  } = _ref;\n\n  const wrappedValueGetter = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      var _cellAggregationResul;\n\n      return (_cellAggregationResul = cellAggregationResult == null ? void 0 : cellAggregationResult.value) != null ? _cellAggregationResul : null;\n    }\n\n    if (valueGetter) {\n      return valueGetter(params);\n    }\n\n    return params.row[params.field];\n  };\n\n  return wrappedValueGetter;\n};\n\nconst getAggregationValueWrappedValueFormatter = _ref2 => {\n  let {\n    value: valueFormatter,\n    aggregationRule,\n    getCellAggregationResult\n  } = _ref2;\n\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n\n  const wrappedValueFormatter = params => {\n    if (params.id != null) {\n      const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter(params);\n      }\n    }\n\n    if (valueFormatter) {\n      return valueFormatter(params);\n    }\n\n    return params.value;\n  };\n\n  return wrappedValueFormatter;\n};\n\nconst getAggregationValueWrappedRenderCell = _ref3 => {\n  let {\n    value: renderCell,\n    aggregationRule,\n    getCellAggregationResult\n  } = _ref3;\n\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      var _aggregationFunction$;\n\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/_jsx(GridFooterCell, _extends({}, params));\n        }\n\n        return params.formattedValue;\n      }\n\n      const aggregationMeta = {\n        hasCellUnit: (_aggregationFunction$ = aggregationRule.aggregationFunction.hasCellUnit) != null ? _aggregationFunction$ : true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell(_extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n\n    return renderCell(params);\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Skips the filtering for aggregated rows\n */\n\n\nconst getWrappedFilterOperators = _ref4 => {\n  let {\n    value: filterOperators,\n    getCellAggregationResult\n  } = _ref4;\n  return filterOperators.map(operator => {\n    return _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          if (getCellAggregationResult(params.id, params.field) != null) {\n            return true;\n          }\n\n          return originalFn(params);\n        };\n      }\n    });\n  });\n};\n/**\n * Add the aggregation method around the header name\n */\n\n\nconst getWrappedRenderHeader = _ref5 => {\n  let {\n    value: renderHeader,\n    aggregationRule\n  } = _ref5;\n\n  const wrappedRenderCell = params => {\n    const aggregationMeta = {\n      aggregationRule\n    };\n\n    if (!renderHeader) {\n      return /*#__PURE__*/_jsx(GridAggregationHeader, _extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    return renderHeader(_extends({}, params, {\n      aggregation: aggregationMeta\n    }));\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\n\n\nexport const wrapColumnWithAggregationValue = _ref6 => {\n  let {\n    column,\n    apiRef,\n    aggregationRule\n  } = _ref6;\n\n  const getCellAggregationResult = (id, field) => {\n    var _rowNode$children, _rowNode$parent, _gridAggregationLooku;\n\n    let cellAggregationPosition = null;\n    const rowNode = apiRef.current.getRowNode(id);\n\n    if ((_rowNode$children = rowNode.children) != null && _rowNode$children.length) {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n\n    if (cellAggregationPosition == null) {\n      return null;\n    } // TODO: Add custom root id\n\n\n    const groupId = cellAggregationPosition === 'inline' ? id : (_rowNode$parent = rowNode.parent) != null ? _rowNode$parent : '';\n    const aggregationResult = (_gridAggregationLooku = gridAggregationLookupSelector(apiRef)[groupId]) == null ? void 0 : _gridAggregationLooku[field];\n\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n\n    return aggregationResult;\n  };\n\n  const aggregationWrappedProperties = {};\n\n  const wrappedColumn = _extends({}, column, {\n    aggregationWrappedProperties\n  });\n\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n\n    if (wrappedProperty !== originalValue) {\n      aggregationWrappedProperties[property] = {\n        original: originalValue,\n        wrapped: wrappedProperty\n      };\n      wrappedColumn[property] = wrappedProperty;\n    }\n  };\n\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n\n  if (Object.keys(aggregationWrappedProperties).length === 0) {\n    return column;\n  }\n\n  return wrappedColumn;\n};\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\n\nexport const unwrapColumnFromAggregation = _ref7 => {\n  let {\n    column\n  } = _ref7;\n\n  if (!column.aggregationWrappedProperties) {\n    return column;\n  }\n\n  const originalProperties = Object.entries(column.aggregationWrappedProperties);\n\n  if (originalProperties.length === 0) {\n    return column;\n  }\n\n  const unwrappedColumn = _extends({}, column);\n\n  originalProperties.forEach(_ref8 => {\n    let [propertyName, {\n      original,\n      wrapped\n    }] = _ref8;\n\n    // The value changed since we wrapped it\n    if (wrapped !== column[propertyName]) {\n      return;\n    }\n\n    unwrappedColumn[propertyName] = original;\n  });\n  return unwrappedColumn;\n};","map":null,"metadata":{},"sourceType":"module"}