{"ast":null,"code":"import * as React from 'react';\nimport { unstable_composeClasses as composeClasses } from '@mui/material';\nimport { useGridLogger, useGridApiEventHandler, getDataGridUtilityClass, useGridSelector, gridSortModelSelector, gridRowTreeDepthSelector, useGridApiOptionHandler, gridEditRowsStateSelector } from '@mui/x-data-grid';\n\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    rowDragging: ['row--dragging']\n  };\n  return composeClasses(slots, getDataGridUtilityClass, classes);\n};\n/**\n * Only available in DataGridPro\n * @requires useGridRows (method)\n */\n\n\nexport const useGridRowReorder = (apiRef, props) => {\n  const logger = useGridLogger(apiRef, 'useGridRowReorder');\n  const sortModel = useGridSelector(apiRef, gridSortModelSelector);\n  const treeDepth = useGridSelector(apiRef, gridRowTreeDepthSelector);\n  const dragRowNode = React.useRef(null);\n  const originRowIndex = React.useRef(null);\n  const removeDnDStylesTimeout = React.useRef();\n  const ownerState = {\n    classes: props.classes\n  };\n  const classes = useUtilityClasses(ownerState);\n  const [dragRowId, setDragRowId] = React.useState('');\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(removeDnDStylesTimeout.current);\n    };\n  }, []); // TODO: remove sortModel check once row reorder is sorting compatible\n  // remove treeDepth once row reorder is tree compatible\n\n  const isRowReorderDisabled = React.useMemo(() => {\n    return !props.rowReordering || !!sortModel.length || treeDepth !== 1;\n  }, [props.rowReordering, sortModel, treeDepth]);\n  const handleDragStart = React.useCallback((params, event) => {\n    // Call the gridEditRowsStateSelector directly to avoid infnite loop\n    const editRowsState = gridEditRowsStateSelector(apiRef.current.state);\n\n    if (isRowReorderDisabled || Object.keys(editRowsState).length !== 0) {\n      return;\n    }\n\n    logger.debug(`Start dragging row ${params.id}`); // Prevent drag events propagation.\n    // For more information check here https://github.com/mui/mui-x/issues/2680.\n\n    event.stopPropagation();\n    dragRowNode.current = event.currentTarget;\n    dragRowNode.current.classList.add(classes.rowDragging);\n    setDragRowId(params.id);\n    removeDnDStylesTimeout.current = setTimeout(() => {\n      dragRowNode.current.classList.remove(classes.rowDragging);\n    });\n    originRowIndex.current = apiRef.current.getRowIndex(params.id);\n  }, [isRowReorderDisabled, classes.rowDragging, logger, apiRef]);\n  const handleDragOver = React.useCallback((params, event) => {\n    var _apiRef$current$getRo;\n\n    if (dragRowId === '') {\n      return;\n    }\n\n    if ((_apiRef$current$getRo = apiRef.current.getRowNode(params.id)) != null && _apiRef$current$getRo.isPinned) {\n      return;\n    }\n\n    logger.debug(`Dragging over row ${params.id}`);\n    event.preventDefault(); // Prevent drag events propagation.\n    // For more information check here https://github.com/mui/mui-x/issues/2680.\n\n    event.stopPropagation();\n\n    if (params.id !== dragRowId) {\n      const targetRowIndex = apiRef.current.getRowIndex(params.id);\n      apiRef.current.setRowIndex(dragRowId, targetRowIndex);\n    }\n  }, [apiRef, logger, dragRowId]);\n  const handleDragEnd = React.useCallback((params, event) => {\n    // Call the gridEditRowsStateSelector directly to avoid infnite loop\n    const editRowsState = gridEditRowsStateSelector(apiRef.current.state);\n\n    if (dragRowId === '' || isRowReorderDisabled || Object.keys(editRowsState).length !== 0) {\n      return;\n    }\n\n    logger.debug('End dragging row');\n    event.preventDefault(); // Prevent drag events propagation.\n    // For more information check here https://github.com/mui/mui-x/issues/2680.\n\n    event.stopPropagation();\n    clearTimeout(removeDnDStylesTimeout.current);\n    dragRowNode.current = null; // Check if the row was dropped outside the grid.\n\n    if (event.dataTransfer.dropEffect === 'none') {\n      // Accessing params.field may contain the wrong field as header elements are reused\n      apiRef.current.setRowIndex(dragRowId, originRowIndex.current);\n      originRowIndex.current = null;\n    } else {\n      // Emit the rowOrderChange event only once when the reordering stops.\n      const rowOrderChangeParams = {\n        row: apiRef.current.getRow(dragRowId),\n        targetIndex: apiRef.current.getRowIndex(params.id),\n        oldIndex: originRowIndex.current\n      };\n      apiRef.current.publishEvent('rowOrderChange', rowOrderChangeParams);\n    }\n\n    setDragRowId('');\n  }, [isRowReorderDisabled, logger, apiRef, dragRowId]);\n  useGridApiEventHandler(apiRef, 'rowDragStart', handleDragStart);\n  useGridApiEventHandler(apiRef, 'rowDragOver', handleDragOver);\n  useGridApiEventHandler(apiRef, 'rowDragEnd', handleDragEnd);\n  useGridApiEventHandler(apiRef, 'cellDragOver', handleDragOver);\n  useGridApiOptionHandler(apiRef, 'rowOrderChange', props.onRowOrderChange);\n};","map":null,"metadata":{},"sourceType":"module"}