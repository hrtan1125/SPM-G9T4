{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport const getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\n/**\n * Transform a list of rows into a tree structure where each row references its parent and children.\n * If a row have a parent which does not exist in the input rows, creates an auto generated row\n *\n ```\n params = {\n   ids: [0, 1, 2],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...} },\n   rows: [\n     { id: 0, path: ['A'] },\n     { id: 1, path: ['B', 'A'] },\n     { id: 2, path: ['B', 'A', 'A'] }\n   ],\n   defaultGroupingExpansionDepth: 0,\n }\n Returns:\n {\n   ids: [0, 1, 2, 'auto-generated-row-B'],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...}, 'auto-generated-row-B': {} },\n   tree: {\n     '0': { id: 0, parent: null, childrenExpanded: false, depth: 0, groupingKey: 'A' },\n     'auto-generated-row-B': { id: 'auto-generated-row-B', parent: null, childrenExpanded: false, depth: 0, groupingKey: 'B' },\n     '1': { id: 1, parent: 'auto-generated-row-B', childrenExpanded: false, depth: 1, groupingKey: 'A' },\n     '2': { id: 2, parent: 1, childrenExpanded: false, depth: 2, groupingKey: 'A' },\n   },\n   treeDepth: 3,\n }\n ```\n */\n\nexport const buildRowTree = params => {\n  // During the build, we store the children as a Record to avoid linear complexity when checking if a children is already defined.\n  const tempTree = {};\n  let treeDepth = 1;\n  const ids = [...params.ids];\n\n  const idRowsLookup = _extends({}, params.idRowsLookup);\n\n  const idToIdLookup = _extends({}, params.idToIdLookup);\n\n  const groupingCriteriaToIdTree = {};\n\n  const isGroupExpandedByDefault = node => {\n    var _params$previousTree, _params$previousTree$;\n\n    const previousExpansion = (_params$previousTree = params.previousTree) == null ? void 0 : (_params$previousTree$ = _params$previousTree[node.id]) == null ? void 0 : _params$previousTree$.childrenExpanded;\n\n    if (previousExpansion != null) {\n      return previousExpansion;\n    }\n\n    if (!node.children || !node.children.length) {\n      return undefined;\n    }\n\n    if (params.isGroupExpandedByDefault) {\n      return params.isGroupExpandedByDefault(node);\n    }\n\n    return params.defaultGroupingExpansionDepth === -1 || params.defaultGroupingExpansionDepth > node.depth;\n  };\n\n  for (let i = 0; i < params.rows.length; i += 1) {\n    const row = params.rows[i];\n    let keyToIdSubTree = groupingCriteriaToIdTree;\n    let parentNode = null;\n\n    for (let depth = 0; depth < row.path.length; depth += 1) {\n      const {\n        key,\n        field: rawField\n      } = row.path[depth];\n      const field = rawField != null ? rawField : '__no_field__';\n      let nodeId;\n      let fieldSubTree = keyToIdSubTree[field];\n\n      if (!fieldSubTree) {\n        fieldSubTree = {};\n        keyToIdSubTree[field] = fieldSubTree;\n      }\n\n      let keyConfig = fieldSubTree[key.toString()];\n\n      if (keyConfig) {\n        if (depth === row.path.length - 1) {\n          var _params$onDuplicatePa;\n\n          (_params$onDuplicatePa = params.onDuplicatePath) == null ? void 0 : _params$onDuplicatePa.call(params, keyConfig.id, row.id, row.path);\n        }\n\n        nodeId = keyConfig.id;\n      } else {\n        if (depth === row.path.length - 1) {\n          nodeId = row.id;\n        } else {\n          nodeId = getGroupRowIdFromPath(row.path.slice(0, depth + 1));\n        }\n\n        keyConfig = {\n          id: nodeId,\n          children: {}\n        };\n        fieldSubTree[key.toString()] = keyConfig;\n      }\n\n      keyToIdSubTree = keyConfig.children;\n\n      if (!tempTree[nodeId]) {\n        var _parentNode$id, _parentNode;\n\n        const isAutoGenerated = depth < row.path.length - 1;\n        const node = {\n          id: nodeId,\n          isAutoGenerated,\n          parent: (_parentNode$id = (_parentNode = parentNode) == null ? void 0 : _parentNode.id) != null ? _parentNode$id : null,\n          groupingKey: key,\n          groupingField: rawField,\n          depth\n        };\n\n        if (isAutoGenerated) {\n          idRowsLookup[nodeId] = {};\n          ids.push(nodeId);\n        }\n\n        tempTree[nodeId] = node;\n      }\n\n      if (parentNode != null) {\n        if (!parentNode.children) {\n          parentNode.children = {};\n        }\n\n        parentNode.children[nodeId] = nodeId;\n      }\n\n      parentNode = tempTree[nodeId];\n    }\n\n    treeDepth = Math.max(treeDepth, row.path.length);\n  }\n\n  const tree = {};\n\n  for (let i = 0; i < ids.length; i += 1) {\n    var _params$previousTree2, _previousNode$childre, _node$children, _previousNode$childre2;\n\n    const rowId = ids[i];\n    const tempNode = tempTree[rowId];\n\n    const nodeWithoutChildrenExpansion = _extends({}, tempNode, {\n      children: tempNode.children ? Object.values(tempNode.children) : undefined\n    });\n\n    const node = _extends({}, nodeWithoutChildrenExpansion, {\n      childrenExpanded: isGroupExpandedByDefault(nodeWithoutChildrenExpansion)\n    });\n\n    const previousNode = (_params$previousTree2 = params.previousTree) == null ? void 0 : _params$previousTree2[node.id];\n    const shouldReUsePreviousNode = previousNode && previousNode.isAutoGenerated === node.isAutoGenerated && previousNode.parent === node.parent && previousNode.groupingKey === node.groupingKey && previousNode.groupingField === node.groupingField && previousNode.depth === node.depth && previousNode.childrenExpanded === node.childrenExpanded && ((_previousNode$childre = previousNode.children) == null ? void 0 : _previousNode$childre.length) === ((_node$children = node.children) == null ? void 0 : _node$children.length) && ((_previousNode$childre2 = previousNode.children) == null ? void 0 : _previousNode$childre2.every((childId, index) => {\n      var _node$children2;\n\n      return ((_node$children2 = node.children) == null ? void 0 : _node$children2[index]) === childId;\n    }));\n\n    if (shouldReUsePreviousNode) {\n      tree[rowId] = previousNode;\n    } else {\n      tree[rowId] = node;\n    }\n  }\n\n  return {\n    tree,\n    treeDepth,\n    ids,\n    idRowsLookup,\n    idToIdLookup,\n    groupingName: params.groupingName\n  };\n};","map":null,"metadata":{},"sourceType":"module"}