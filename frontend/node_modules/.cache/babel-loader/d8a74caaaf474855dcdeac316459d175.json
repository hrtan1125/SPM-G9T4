{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { ownerDocument, useEventCallback } from '@mui/material/utils';\nimport { gridClasses, useGridApiEventHandler, useGridApiOptionHandler, useGridNativeEventListener, useGridLogger } from '@mui/x-data-grid';\nimport { clamp, findParentElementFromClassName } from '@mui/x-data-grid/internals';\nimport { useTheme } from '@mui/material/styles';\nimport { findGridCellElementsFromCol, getFieldFromHeaderElem, findHeaderElementFromField, findGroupHeaderElementsFromField } from '../../../utils/domUtils'; // TODO: remove support for Safari < 13.\n// https://caniuse.com/#search=touch-action\n//\n// Safari, on iOS, supports touch action since v13.\n// Over 80% of the iOS phones are compatible\n// in August 2020.\n// Utilizing the CSS.supports method to check if touch-action is supported.\n// Since CSS.supports is supported on all but Edge@12 and IE and touch-action\n// is supported on both Edge@12 and IE if CSS.supports is not available that means that\n// touch-action will be supported\n\nlet cachedSupportsTouchActionNone = false;\n\nfunction doesSupportTouchActionNone() {\n  if (cachedSupportsTouchActionNone === undefined) {\n    if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {\n      cachedSupportsTouchActionNone = CSS.supports('touch-action', 'none');\n    } else {\n      cachedSupportsTouchActionNone = true;\n    }\n  }\n\n  return cachedSupportsTouchActionNone;\n}\n\nfunction trackFinger(event, currentTouchId) {\n  if (currentTouchId !== undefined && event.changedTouches) {\n    for (let i = 0; i < event.changedTouches.length; i += 1) {\n      const touch = event.changedTouches[i];\n\n      if (touch.identifier === currentTouchId) {\n        return {\n          x: touch.clientX,\n          y: touch.clientY\n        };\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    x: event.clientX,\n    y: event.clientY\n  };\n}\n\nfunction computeNewWidth(initialOffsetToSeparator, clickX, columnBounds, resizeDirection) {\n  let newWidth = initialOffsetToSeparator;\n\n  if (resizeDirection === 'Right') {\n    newWidth += clickX - columnBounds.left;\n  } else {\n    newWidth += columnBounds.right - clickX;\n  }\n\n  return newWidth;\n}\n\nfunction computeOffsetToSeparator(clickX, columnBounds, resizeDirection) {\n  if (resizeDirection === 'Left') {\n    return clickX - columnBounds.left;\n  }\n\n  return columnBounds.right - clickX;\n}\n\nfunction flipResizeDirection(side) {\n  if (side === 'Right') {\n    return 'Left';\n  }\n\n  return 'Right';\n}\n\nfunction getResizeDirection(element, direction) {\n  const side = element.classList.contains(gridClasses['columnSeparator--sideRight']) ? 'Right' : 'Left';\n\n  if (direction === 'rtl') {\n    // Resizing logic should be mirrored in the RTL case\n    return flipResizeDirection(side);\n  }\n\n  return side;\n}\n\nexport const columnResizeStateInitializer = state => _extends({}, state, {\n  columnResize: {\n    resizingColumnField: ''\n  }\n});\n/**\n * @requires useGridColumns (method, event)\n * TODO: improve experience for last column\n */\n\nexport const useGridColumnResize = (apiRef, props) => {\n  const logger = useGridLogger(apiRef, 'useGridColumnResize');\n  const colDefRef = React.useRef();\n  const colElementRef = React.useRef();\n  const colGroupingElementRef = React.useRef();\n  const colCellElementsRef = React.useRef();\n  const theme = useTheme(); // To improve accessibility, the separator has padding on both sides.\n  // Clicking inside the padding area should be treated as a click in the separator.\n  // This ref stores the offset between the click and the separator.\n\n  const initialOffsetToSeparator = React.useRef();\n  const resizeDirection = React.useRef();\n  const stopResizeEventTimeout = React.useRef();\n  const touchId = React.useRef();\n\n  const updateWidth = newWidth => {\n    logger.debug(`Updating width to ${newWidth} for col ${colDefRef.current.field}`);\n    const prevWidth = colElementRef.current.offsetWidth;\n    const widthDiff = newWidth - prevWidth;\n    colDefRef.current.computedWidth = newWidth;\n    colDefRef.current.width = newWidth;\n    colDefRef.current.flex = 0;\n    colElementRef.current.style.width = `${newWidth}px`;\n    colElementRef.current.style.minWidth = `${newWidth}px`;\n    colElementRef.current.style.maxWidth = `${newWidth}px`;\n    [...colCellElementsRef.current, ...colGroupingElementRef.current].forEach(element => {\n      const div = element;\n      let finalWidth;\n\n      if (div.getAttribute('aria-colspan') === '1') {\n        finalWidth = `${newWidth}px`;\n      } else {\n        // Cell with colspan > 1 cannot be just updated width new width.\n        // Instead, we add width diff to the current width.\n        finalWidth = `${div.offsetWidth + widthDiff}px`;\n      }\n\n      div.style.width = finalWidth;\n      div.style.minWidth = finalWidth;\n      div.style.maxWidth = finalWidth;\n    });\n  };\n\n  const handleResizeMouseUp = useEventCallback(nativeEvent => {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    stopListening();\n    apiRef.current.updateColumn(colDefRef.current);\n    clearTimeout(stopResizeEventTimeout.current);\n    stopResizeEventTimeout.current = setTimeout(() => {\n      apiRef.current.publishEvent('columnResizeStop', null, nativeEvent);\n\n      if (colDefRef.current) {\n        var _colDefRef$current;\n\n        apiRef.current.publishEvent('columnWidthChange', {\n          element: colElementRef.current,\n          colDef: colDefRef.current,\n          width: (_colDefRef$current = colDefRef.current) == null ? void 0 : _colDefRef$current.computedWidth\n        }, nativeEvent);\n      }\n    });\n    logger.debug(`Updating col ${colDefRef.current.field} with new width: ${colDefRef.current.width}`);\n  });\n  const handleResizeMouseMove = useEventCallback(nativeEvent => {\n    // Cancel move in case some other element consumed a mouseup event and it was not fired.\n    if (nativeEvent.buttons === 0) {\n      handleResizeMouseUp(nativeEvent);\n      return;\n    }\n\n    let newWidth = computeNewWidth(initialOffsetToSeparator.current, nativeEvent.clientX, colElementRef.current.getBoundingClientRect(), resizeDirection.current);\n    newWidth = clamp(newWidth, colDefRef.current.minWidth, colDefRef.current.maxWidth);\n    updateWidth(newWidth);\n    const params = {\n      element: colElementRef.current,\n      colDef: colDefRef.current,\n      width: newWidth\n    };\n    apiRef.current.publishEvent('columnResize', params, nativeEvent);\n  });\n  const handleColumnResizeMouseDown = useEventCallback((_ref, event) => {\n    let {\n      colDef\n    } = _ref;\n\n    var _apiRef$current$colum, _apiRef$current$colum2; // Only handle left clicks\n\n\n    if (event.button !== 0) {\n      return;\n    } // Skip if the column isn't resizable\n\n\n    if (!event.currentTarget.classList.contains(gridClasses['columnSeparator--resizable'])) {\n      return;\n    } // Avoid text selection\n\n\n    event.preventDefault();\n    logger.debug(`Start Resize on col ${colDef.field}`);\n    apiRef.current.publishEvent('columnResizeStart', {\n      field: colDef.field\n    }, event);\n    colDefRef.current = colDef;\n    colElementRef.current = (_apiRef$current$colum = apiRef.current.columnHeadersContainerElementRef) == null ? void 0 : _apiRef$current$colum.current.querySelector(`[data-field=\"${colDef.field}\"]`);\n    colGroupingElementRef.current = findGroupHeaderElementsFromField((_apiRef$current$colum2 = apiRef.current.columnHeadersContainerElementRef) == null ? void 0 : _apiRef$current$colum2.current, colDef.field);\n    colCellElementsRef.current = findGridCellElementsFromCol(colElementRef.current, apiRef.current);\n    const doc = ownerDocument(apiRef.current.rootElementRef.current);\n    doc.body.style.cursor = 'col-resize';\n    resizeDirection.current = getResizeDirection(event.currentTarget, theme.direction);\n    initialOffsetToSeparator.current = computeOffsetToSeparator(event.clientX, colElementRef.current.getBoundingClientRect(), resizeDirection.current);\n    doc.addEventListener('mousemove', handleResizeMouseMove);\n    doc.addEventListener('mouseup', handleResizeMouseUp);\n  });\n  const handleTouchEnd = useEventCallback(nativeEvent => {\n    const finger = trackFinger(nativeEvent, touchId.current);\n\n    if (!finger) {\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n    stopListening();\n    apiRef.current.updateColumn(colDefRef.current);\n    clearTimeout(stopResizeEventTimeout.current);\n    stopResizeEventTimeout.current = setTimeout(() => {\n      apiRef.current.publishEvent('columnResizeStop', null, nativeEvent);\n    });\n    logger.debug(`Updating col ${colDefRef.current.field} with new width: ${colDefRef.current.width}`);\n  });\n  const handleTouchMove = useEventCallback(nativeEvent => {\n    const finger = trackFinger(nativeEvent, touchId.current);\n\n    if (!finger) {\n      return;\n    } // Cancel move in case some other element consumed a touchmove event and it was not fired.\n\n\n    if (nativeEvent.type === 'mousemove' && nativeEvent.buttons === 0) {\n      handleTouchEnd(nativeEvent);\n      return;\n    }\n\n    let newWidth = computeNewWidth(initialOffsetToSeparator.current, finger.x, colElementRef.current.getBoundingClientRect(), resizeDirection.current);\n    newWidth = clamp(newWidth, colDefRef.current.minWidth, colDefRef.current.maxWidth);\n    updateWidth(newWidth);\n    const params = {\n      element: colElementRef.current,\n      colDef: colDefRef.current,\n      width: newWidth\n    };\n    apiRef.current.publishEvent('columnResize', params, nativeEvent);\n  });\n  const handleTouchStart = useEventCallback(event => {\n    var _apiRef$current$colum3, _apiRef$current$colum4;\n\n    const cellSeparator = findParentElementFromClassName(event.target, gridClasses['columnSeparator--resizable']); // Let the event bubble if the target is not a col separator\n\n    if (!cellSeparator) {\n      return;\n    } // If touch-action: none; is not supported we need to prevent the scroll manually.\n\n\n    if (!doesSupportTouchActionNone()) {\n      event.preventDefault();\n    }\n\n    const touch = event.changedTouches[0];\n\n    if (touch != null) {\n      // A number that uniquely identifies the current finger in the touch session.\n      touchId.current = touch.identifier;\n    }\n\n    colElementRef.current = findParentElementFromClassName(event.target, gridClasses.columnHeader);\n    const field = getFieldFromHeaderElem(colElementRef.current);\n    const colDef = apiRef.current.getColumn(field);\n    colGroupingElementRef.current = findGroupHeaderElementsFromField((_apiRef$current$colum3 = apiRef.current.columnHeadersContainerElementRef) == null ? void 0 : _apiRef$current$colum3.current, field);\n    logger.debug(`Start Resize on col ${colDef.field}`);\n    apiRef.current.publishEvent('columnResizeStart', {\n      field\n    }, event);\n    colDefRef.current = colDef;\n    colElementRef.current = findHeaderElementFromField((_apiRef$current$colum4 = apiRef.current.columnHeadersElementRef) == null ? void 0 : _apiRef$current$colum4.current, colDef.field);\n    colCellElementsRef.current = findGridCellElementsFromCol(colElementRef.current, apiRef.current);\n    resizeDirection.current = getResizeDirection(event.target, theme.direction);\n    initialOffsetToSeparator.current = computeOffsetToSeparator(touch.clientX, colElementRef.current.getBoundingClientRect(), resizeDirection.current);\n    const doc = ownerDocument(event.currentTarget);\n    doc.addEventListener('touchmove', handleTouchMove);\n    doc.addEventListener('touchend', handleTouchEnd);\n  });\n  const stopListening = React.useCallback(() => {\n    const doc = ownerDocument(apiRef.current.rootElementRef.current);\n    doc.body.style.removeProperty('cursor');\n    doc.removeEventListener('mousemove', handleResizeMouseMove);\n    doc.removeEventListener('mouseup', handleResizeMouseUp);\n    doc.removeEventListener('touchmove', handleTouchMove);\n    doc.removeEventListener('touchend', handleTouchEnd);\n  }, [apiRef, handleResizeMouseMove, handleResizeMouseUp, handleTouchMove, handleTouchEnd]);\n  const handleResizeStart = React.useCallback(_ref2 => {\n    let {\n      field\n    } = _ref2;\n    apiRef.current.setState(state => _extends({}, state, {\n      columnResize: _extends({}, state.columnResize, {\n        resizingColumnField: field\n      })\n    }));\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  const handleResizeStop = React.useCallback(() => {\n    apiRef.current.setState(state => _extends({}, state, {\n      columnResize: _extends({}, state.columnResize, {\n        resizingColumnField: ''\n      })\n    }));\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(stopResizeEventTimeout.current);\n      stopListening();\n    };\n  }, [apiRef, handleTouchStart, stopListening]);\n  useGridNativeEventListener(apiRef, () => {\n    var _apiRef$current$colum5;\n\n    return (_apiRef$current$colum5 = apiRef.current.columnHeadersElementRef) == null ? void 0 : _apiRef$current$colum5.current;\n  }, 'touchstart', handleTouchStart, {\n    passive: doesSupportTouchActionNone()\n  });\n  useGridApiEventHandler(apiRef, 'columnSeparatorMouseDown', handleColumnResizeMouseDown);\n  useGridApiEventHandler(apiRef, 'columnResizeStart', handleResizeStart);\n  useGridApiEventHandler(apiRef, 'columnResizeStop', handleResizeStop);\n  useGridApiOptionHandler(apiRef, 'columnResize', props.onColumnResize);\n  useGridApiOptionHandler(apiRef, 'columnWidthChange', props.onColumnWidthChange);\n};","map":null,"metadata":{},"sourceType":"module"}