{"ast":null,"code":"import * as React from 'react';\nimport { useGridApiEventHandler, GridFeatureModeConstant, useGridSelector, gridSortModelSelector, gridFilterModelSelector, useGridApiOptionHandler } from '@mui/x-data-grid';\nimport { useGridVisibleRows, getRenderableIndexes } from '@mui/x-data-grid/internals';\n\nfunction findSkeletonRowsSection(visibleRows, range) {\n  let {\n    firstRowIndex,\n    lastRowIndex\n  } = range;\n  const visibleRowsSection = visibleRows.slice(range.firstRowIndex, range.lastRowIndex);\n  let startIndex = 0;\n  let endIndex = visibleRowsSection.length - 1;\n  let isSkeletonSectionFound = false;\n\n  while (!isSkeletonSectionFound && firstRowIndex < lastRowIndex) {\n    if (!visibleRowsSection[startIndex].model && !visibleRowsSection[endIndex].model) {\n      isSkeletonSectionFound = true;\n    }\n\n    if (visibleRowsSection[startIndex].model) {\n      startIndex += 1;\n      firstRowIndex += 1;\n    }\n\n    if (visibleRowsSection[endIndex].model) {\n      endIndex -= 1;\n      lastRowIndex -= 1;\n    }\n  }\n\n  return isSkeletonSectionFound ? {\n    firstRowIndex,\n    lastRowIndex\n  } : undefined;\n}\n\nfunction isLazyLoadingDisabled(_ref) {\n  let {\n    lazyLoadingFeatureFlag,\n    rowsLoadingMode,\n    gridDimensions\n  } = _ref;\n\n  if (!lazyLoadingFeatureFlag || !gridDimensions) {\n    return true;\n  }\n\n  if (rowsLoadingMode !== GridFeatureModeConstant.server) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * @requires useGridRows (state)\n * @requires useGridPagination (state)\n * @requires useGridDimensions (method) - can be after\n * @requires useGridScroll (method\n */\n\n\nexport const useGridLazyLoader = (apiRef, props) => {\n  var _props$experimentalFe;\n\n  const visibleRows = useGridVisibleRows(apiRef, props);\n  const sortModel = useGridSelector(apiRef, gridSortModelSelector);\n  const filterModel = useGridSelector(apiRef, gridFilterModelSelector);\n  const renderedRowsIntervalCache = React.useRef({\n    firstRowToRender: 0,\n    lastRowToRender: 0\n  });\n  const {\n    lazyLoading\n  } = (_props$experimentalFe = props.experimentalFeatures) != null ? _props$experimentalFe : {};\n  const getCurrentIntervalToRender = React.useCallback(() => {\n    const currentRenderContext = apiRef.current.unstable_getRenderContext();\n    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({\n      firstIndex: currentRenderContext.firstRowIndex,\n      lastIndex: currentRenderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: visibleRows.rows.length,\n      buffer: props.rowBuffer\n    });\n    return {\n      firstRowToRender,\n      lastRowToRender\n    };\n  }, [apiRef, props.rowBuffer, visibleRows.rows.length]);\n  const handleRenderedRowsIntervalChange = React.useCallback(params => {\n    const dimensions = apiRef.current.getRootDimensions();\n\n    if (isLazyLoadingDisabled({\n      lazyLoadingFeatureFlag: lazyLoading,\n      rowsLoadingMode: props.rowsLoadingMode,\n      gridDimensions: dimensions\n    })) {\n      return;\n    }\n\n    const fetchRowsParams = {\n      firstRowToRender: params.firstRowToRender,\n      lastRowToRender: params.lastRowToRender,\n      sortModel,\n      filterModel\n    };\n\n    if (renderedRowsIntervalCache.current.firstRowToRender === params.firstRowToRender && renderedRowsIntervalCache.current.lastRowToRender === params.lastRowToRender) {\n      return;\n    }\n\n    if (sortModel.length === 0 && filterModel.items.length === 0) {\n      const skeletonRowsSection = findSkeletonRowsSection(visibleRows.rows, {\n        firstRowIndex: params.firstRowToRender,\n        lastRowIndex: params.lastRowToRender\n      });\n\n      if (!skeletonRowsSection) {\n        return;\n      }\n\n      fetchRowsParams.firstRowToRender = skeletonRowsSection.firstRowIndex;\n      fetchRowsParams.lastRowToRender = skeletonRowsSection.lastRowIndex;\n    }\n\n    renderedRowsIntervalCache.current = params;\n    apiRef.current.publishEvent('fetchRows', fetchRowsParams);\n  }, [apiRef, props.rowsLoadingMode, sortModel, filterModel, visibleRows.rows, lazyLoading]);\n  const handleGridSortModelChange = React.useCallback(newSortModel => {\n    const dimensions = apiRef.current.getRootDimensions();\n\n    if (isLazyLoadingDisabled({\n      lazyLoadingFeatureFlag: lazyLoading,\n      rowsLoadingMode: props.rowsLoadingMode,\n      gridDimensions: dimensions\n    })) {\n      return;\n    }\n\n    apiRef.current.unstable_requestPipeProcessorsApplication('hydrateRows');\n    const {\n      firstRowToRender,\n      lastRowToRender\n    } = getCurrentIntervalToRender();\n    const fetchRowsParams = {\n      firstRowToRender,\n      lastRowToRender,\n      sortModel: newSortModel,\n      filterModel\n    };\n    apiRef.current.publishEvent('fetchRows', fetchRowsParams);\n  }, [apiRef, props.rowsLoadingMode, filterModel, lazyLoading, getCurrentIntervalToRender]);\n  const handleGridFilterModelChange = React.useCallback(newFilterModel => {\n    const dimensions = apiRef.current.getRootDimensions();\n\n    if (isLazyLoadingDisabled({\n      lazyLoadingFeatureFlag: lazyLoading,\n      rowsLoadingMode: props.rowsLoadingMode,\n      gridDimensions: dimensions\n    })) {\n      return;\n    }\n\n    apiRef.current.unstable_requestPipeProcessorsApplication('hydrateRows');\n    const {\n      firstRowToRender,\n      lastRowToRender\n    } = getCurrentIntervalToRender();\n    const fetchRowsParams = {\n      firstRowToRender,\n      lastRowToRender,\n      sortModel,\n      filterModel: newFilterModel\n    };\n    apiRef.current.publishEvent('fetchRows', fetchRowsParams);\n  }, [apiRef, props.rowsLoadingMode, sortModel, lazyLoading, getCurrentIntervalToRender]);\n  useGridApiEventHandler(apiRef, 'renderedRowsIntervalChange', handleRenderedRowsIntervalChange);\n  useGridApiEventHandler(apiRef, 'sortModelChange', handleGridSortModelChange);\n  useGridApiEventHandler(apiRef, 'filterModelChange', handleGridFilterModelChange);\n  useGridApiOptionHandler(apiRef, 'fetchRows', props.onFetchRows);\n};","map":null,"metadata":{},"sourceType":"module"}