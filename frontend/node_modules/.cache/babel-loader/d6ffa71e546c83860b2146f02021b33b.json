{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport MuiDivider from '@mui/material/Divider';\nimport { useGridApiEventHandler, useGridApiMethod, gridFilteredDescendantCountLookupSelector, gridColumnLookupSelector } from '@mui/x-data-grid-pro';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid-pro/internals';\nimport { gridRowGroupingModelSelector, gridRowGroupingSanitizedModelSelector } from './gridRowGroupingSelector';\nimport { getRowGroupingFieldFromGroupingCriteria, ROW_GROUPING_STRATEGY, isGroupingColumn, mergeStateWithRowGroupingModel, setStrategyAvailability, getGroupingRules, areGroupingRulesEqual } from './gridRowGroupingUtils';\nimport { GridRowGroupableColumnMenuItems } from '../../../components/GridRowGroupableColumnMenuItems';\nimport { GridRowGroupingColumnMenuItems } from '../../../components/GridRowGroupingColumnMenuItems';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst Divider = () => /*#__PURE__*/_jsx(MuiDivider, {\n  onClick: event => event.stopPropagation()\n});\n\nexport const rowGroupingStateInitializer = (state, props, apiRef) => {\n  var _ref, _props$rowGroupingMod, _props$initialState, _props$initialState$r;\n\n  apiRef.current.unstable_caches.rowGrouping = {\n    rulesOnLastRowTreeCreation: []\n  };\n  return _extends({}, state, {\n    rowGrouping: {\n      model: (_ref = (_props$rowGroupingMod = props.rowGroupingModel) != null ? _props$rowGroupingMod : (_props$initialState = props.initialState) == null ? void 0 : (_props$initialState$r = _props$initialState.rowGrouping) == null ? void 0 : _props$initialState$r.model) != null ? _ref : []\n    }\n  });\n};\n/**\n * @requires useGridColumns (state, method) - can be after, async only\n * @requires useGridRows (state, method) - can be after, async only\n * @requires useGridParamsApi (method) - can be after, async only\n */\n\nexport const useGridRowGrouping = (apiRef, props) => {\n  var _props$initialState3, _props$initialState3$;\n\n  apiRef.current.unstable_registerControlState({\n    stateId: 'rowGrouping',\n    propModel: props.rowGroupingModel,\n    propOnChange: props.onRowGroupingModelChange,\n    stateSelector: gridRowGroupingModelSelector,\n    changeEvent: 'rowGroupingModelChange'\n  });\n  /**\n   * API METHODS\n   */\n\n  const setRowGroupingModel = React.useCallback(model => {\n    const currentModel = gridRowGroupingModelSelector(apiRef);\n\n    if (currentModel !== model) {\n      apiRef.current.setState(mergeStateWithRowGroupingModel(model));\n      setStrategyAvailability(apiRef, props.disableRowGrouping);\n      apiRef.current.forceUpdate();\n    }\n  }, [apiRef, props.disableRowGrouping]);\n  const addRowGroupingCriteria = React.useCallback((field, groupingIndex) => {\n    const currentModel = gridRowGroupingModelSelector(apiRef);\n\n    if (currentModel.includes(field)) {\n      return;\n    }\n\n    const cleanGroupingIndex = groupingIndex != null ? groupingIndex : currentModel.length;\n    const updatedModel = [...currentModel.slice(0, cleanGroupingIndex), field, ...currentModel.slice(cleanGroupingIndex)];\n    apiRef.current.setRowGroupingModel(updatedModel);\n  }, [apiRef]);\n  const removeRowGroupingCriteria = React.useCallback(field => {\n    const currentModel = gridRowGroupingModelSelector(apiRef);\n\n    if (!currentModel.includes(field)) {\n      return;\n    }\n\n    apiRef.current.setRowGroupingModel(currentModel.filter(el => el !== field));\n  }, [apiRef]);\n  const setRowGroupingCriteriaIndex = React.useCallback((field, targetIndex) => {\n    const currentModel = gridRowGroupingModelSelector(apiRef);\n    const currentTargetIndex = currentModel.indexOf(field);\n\n    if (currentTargetIndex === -1) {\n      return;\n    }\n\n    const updatedModel = [...currentModel];\n    updatedModel.splice(targetIndex, 0, updatedModel.splice(currentTargetIndex, 1)[0]);\n    apiRef.current.setRowGroupingModel(updatedModel);\n  }, [apiRef]);\n  const rowGroupingApi = {\n    setRowGroupingModel,\n    addRowGroupingCriteria,\n    removeRowGroupingCriteria,\n    setRowGroupingCriteriaIndex\n  };\n  useGridApiMethod(apiRef, rowGroupingApi, 'GridRowGroupingApi');\n  /**\n   * PRE-PROCESSING\n   */\n\n  const addColumnMenuButtons = React.useCallback((initialValue, column) => {\n    if (props.disableRowGrouping) {\n      return initialValue;\n    }\n\n    let menuItems;\n\n    if (isGroupingColumn(column.field)) {\n      menuItems = /*#__PURE__*/_jsx(GridRowGroupingColumnMenuItems, {});\n    } else if (column.groupable) {\n      menuItems = /*#__PURE__*/_jsx(GridRowGroupableColumnMenuItems, {});\n    } else {\n      menuItems = null;\n    }\n\n    if (menuItems == null) {\n      return initialValue;\n    }\n\n    return [...initialValue, /*#__PURE__*/_jsx(Divider, {}), menuItems];\n  }, [props.disableRowGrouping]);\n  const stateExportPreProcessing = React.useCallback((prevState, context) => {\n    var _props$initialState2, _props$initialState2$;\n\n    const rowGroupingModelToExport = gridRowGroupingModelSelector(apiRef);\n    const shouldExportRowGroupingModel = // Always export if the `exportOnlyDirtyModels` property is activated\n    !context.exportOnlyDirtyModels || // Always export if the model is controlled\n    props.rowGroupingModel != null || // Always export if the model has been initialized\n    ((_props$initialState2 = props.initialState) == null ? void 0 : (_props$initialState2$ = _props$initialState2.rowGrouping) == null ? void 0 : _props$initialState2$.model) != null || // Export if the model is not empty\n    Object.keys(rowGroupingModelToExport).length > 0;\n\n    if (!shouldExportRowGroupingModel) {\n      return prevState;\n    }\n\n    return _extends({}, prevState, {\n      rowGrouping: {\n        model: rowGroupingModelToExport\n      }\n    });\n  }, [apiRef, props.rowGroupingModel, (_props$initialState3 = props.initialState) == null ? void 0 : (_props$initialState3$ = _props$initialState3.rowGrouping) == null ? void 0 : _props$initialState3$.model]);\n  const stateRestorePreProcessing = React.useCallback((params, context) => {\n    var _context$stateToResto;\n\n    if (props.disableRowGrouping) {\n      return params;\n    }\n\n    const rowGroupingModel = (_context$stateToResto = context.stateToRestore.rowGrouping) == null ? void 0 : _context$stateToResto.model;\n\n    if (rowGroupingModel != null) {\n      apiRef.current.setState(mergeStateWithRowGroupingModel(rowGroupingModel));\n    }\n\n    return params;\n  }, [apiRef, props.disableRowGrouping]);\n  useGridRegisterPipeProcessor(apiRef, 'columnMenu', addColumnMenuButtons);\n  useGridRegisterPipeProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  /**\n   * EVENTS\n   */\n\n  const handleCellKeyDown = React.useCallback((params, event) => {\n    const cellParams = apiRef.current.getCellParams(params.id, params.field);\n\n    if (isGroupingColumn(cellParams.field) && event.key === ' ' && !event.shiftKey) {\n      var _gridFilteredDescenda;\n\n      event.stopPropagation();\n      event.preventDefault();\n      const filteredDescendantCount = (_gridFilteredDescenda = gridFilteredDescendantCountLookupSelector(apiRef)[params.id]) != null ? _gridFilteredDescenda : 0;\n      const isOnGroupingCell = props.rowGroupingColumnMode === 'single' || getRowGroupingFieldFromGroupingCriteria(params.rowNode.groupingField) === params.field;\n\n      if (!isOnGroupingCell || filteredDescendantCount === 0) {\n        return;\n      }\n\n      apiRef.current.setRowChildrenExpansion(params.id, !params.rowNode.childrenExpanded);\n    }\n  }, [apiRef, props.rowGroupingColumnMode]);\n  const checkGroupingColumnsModelDiff = React.useCallback(() => {\n    const sanitizedRowGroupingModel = gridRowGroupingSanitizedModelSelector(apiRef);\n    const rulesOnLastRowTreeCreation = apiRef.current.unstable_caches.rowGrouping.rulesOnLastRowTreeCreation;\n    const groupingRules = getGroupingRules({\n      sanitizedRowGroupingModel,\n      columnsLookup: gridColumnLookupSelector(apiRef)\n    });\n\n    if (!areGroupingRulesEqual(rulesOnLastRowTreeCreation, groupingRules)) {\n      apiRef.current.unstable_caches.rowGrouping.rulesOnLastRowTreeCreation = groupingRules;\n      apiRef.current.unstable_requestPipeProcessorsApplication('hydrateColumns');\n      setStrategyAvailability(apiRef, props.disableRowGrouping); // Refresh the row tree creation strategy processing\n      // TODO: Add a clean way to re-run a strategy processing without publishing a private event\n\n      if (apiRef.current.unstable_getActiveStrategy('rowTree') === ROW_GROUPING_STRATEGY) {\n        apiRef.current.publishEvent('activeStrategyProcessorChange', 'rowTreeCreation');\n      }\n    }\n  }, [apiRef, props.disableRowGrouping]);\n  useGridApiEventHandler(apiRef, 'cellKeyDown', handleCellKeyDown);\n  useGridApiEventHandler(apiRef, 'columnsChange', checkGroupingColumnsModelDiff);\n  useGridApiEventHandler(apiRef, 'rowGroupingModelChange', checkGroupingColumnsModelDiff);\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    if (props.rowGroupingModel !== undefined) {\n      apiRef.current.setRowGroupingModel(props.rowGroupingModel);\n    }\n  }, [apiRef, props.rowGroupingModel]);\n};","map":null,"metadata":{},"sourceType":"module"}