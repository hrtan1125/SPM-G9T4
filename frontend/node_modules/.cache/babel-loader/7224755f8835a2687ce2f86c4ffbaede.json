{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport LRUCache from 'lru-cache';\nimport { getRealGridData } from '../services/real-data-service';\nimport { getCommodityColumns } from '../columns/commodities.columns';\nimport { getEmployeeColumns } from '../columns/employees.columns';\nimport asyncWorker from '../services/asyncWorker';\nimport { addTreeDataOptionsToDemoData } from '../services/tree-data-generator';\nconst dataCache = new LRUCache({\n  max: 10,\n  ttl: 60 * 5 * 1e3 // 5 minutes\n\n}); // Generate fake data from a seed.\n// It's about x20 faster than getRealData.\n\nasync function extrapolateSeed(rowLength, data) {\n  return new Promise(resolve => {\n    const seed = data.rows;\n    const rows = data.rows.slice();\n    const tasks = {\n      current: rowLength - seed.length\n    };\n\n    function work() {\n      const row = {};\n\n      for (let j = 0; j < data.columns.length; j += 1) {\n        const column = data.columns[j];\n        const index = Math.round(Math.random() * (seed.length - 1));\n\n        if (column.field === 'id') {\n          row.id = `id-${tasks.current + seed.length}`;\n        } else {\n          row[column.field] = seed[index][column.field];\n        }\n      }\n\n      rows.push(row);\n      tasks.current -= 1;\n    }\n\n    asyncWorker({\n      work,\n      done: () => resolve(_extends({}, data, {\n        rows\n      })),\n      tasks\n    });\n  });\n}\n\nconst deepFreeze = object => {\n  // Retrieve the property names defined on object\n  const propNames = Object.getOwnPropertyNames(object); // Freeze properties before freezing self\n  // eslint-disable-next-line no-restricted-syntax\n\n  for (const name of propNames) {\n    const value = object[name];\n\n    if (value && typeof value === 'object') {\n      deepFreeze(value);\n    }\n  }\n\n  return Object.freeze(object);\n};\n\nexport const getColumnsFromOptions = options => {\n  let columns = options.dataSet === 'Commodity' ? getCommodityColumns(options.editable) : getEmployeeColumns();\n\n  if (options.visibleFields) {\n    columns = columns.map(col => {\n      var _options$visibleField;\n\n      return (_options$visibleField = options.visibleFields) != null && _options$visibleField.includes(col.field) ? col : _extends({}, col, {\n        hide: true\n      });\n    });\n  }\n\n  if (options.maxColumns) {\n    columns = columns.slice(0, options.maxColumns);\n  }\n\n  return columns;\n};\nexport const getInitialState = (options, columns) => {\n  var _options$treeData; // TODO v6: Stop using `GridColDef.hide`\n\n\n  const columnVisibilityModel = {};\n  columns.forEach(col => {\n    if (col.hide) {\n      columnVisibilityModel[col.field] = false;\n    }\n  });\n  const groupingField = (_options$treeData = options.treeData) == null ? void 0 : _options$treeData.groupingField;\n\n  if (groupingField) {\n    columnVisibilityModel[groupingField] = false;\n  }\n\n  return {\n    columns: {\n      columnVisibilityModel\n    }\n  };\n};\nexport const useDemoData = options => {\n  var _options$treeData5, _options$treeData6, _options$treeData7;\n\n  const [rowLength, setRowLength] = React.useState(options.rowLength);\n  const [index, setIndex] = React.useState(0);\n  const [loading, setLoading] = React.useState(true);\n  const columns = React.useMemo(() => {\n    return getColumnsFromOptions({\n      dataSet: options.dataSet,\n      editable: options.editable,\n      maxColumns: options.maxColumns,\n      visibleFields: options.visibleFields\n    });\n  }, [options.dataSet, options.editable, options.maxColumns, options.visibleFields]);\n  const [data, setData] = React.useState(() => {\n    return addTreeDataOptionsToDemoData({\n      columns,\n      rows: [],\n      initialState: getInitialState(options, columns)\n    }, options.treeData);\n  });\n  React.useEffect(() => {\n    const cacheKey = `${options.dataSet}-${rowLength}-${index}-${options.maxColumns}`; // Cache to allow fast switch between the JavaScript and TypeScript version\n    // of the demos.\n\n    if (dataCache.has(cacheKey)) {\n      const newData = dataCache.get(cacheKey);\n      setData(newData);\n      setLoading(false);\n      return undefined;\n    }\n\n    let active = true;\n\n    (async () => {\n      var _options$treeData2, _options$treeData3, _options$treeData4;\n\n      setLoading(true);\n      let newData;\n\n      if (rowLength > 1000) {\n        newData = await getRealGridData(1000, columns);\n        newData = await extrapolateSeed(rowLength, newData);\n      } else {\n        newData = await getRealGridData(rowLength, columns);\n      }\n\n      if (!active) {\n        return;\n      }\n\n      newData = addTreeDataOptionsToDemoData(newData, {\n        maxDepth: (_options$treeData2 = options.treeData) == null ? void 0 : _options$treeData2.maxDepth,\n        groupingField: (_options$treeData3 = options.treeData) == null ? void 0 : _options$treeData3.groupingField,\n        averageChildren: (_options$treeData4 = options.treeData) == null ? void 0 : _options$treeData4.averageChildren\n      }); // It's quite slow. No need for it in production.\n\n      if (process.env.NODE_ENV !== 'production') {\n        deepFreeze(newData);\n      }\n\n      dataCache.set(cacheKey, newData);\n      setData(newData);\n      setLoading(false);\n    })();\n\n    return () => {\n      active = false;\n    };\n  }, [rowLength, options.dataSet, options.maxColumns, (_options$treeData5 = options.treeData) == null ? void 0 : _options$treeData5.maxDepth, (_options$treeData6 = options.treeData) == null ? void 0 : _options$treeData6.groupingField, (_options$treeData7 = options.treeData) == null ? void 0 : _options$treeData7.averageChildren, index, columns]);\n  return {\n    data,\n    loading,\n    setRowLength,\n    loadNewData: () => {\n      setIndex(oldIndex => oldIndex + 1);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"module"}